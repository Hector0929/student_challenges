<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 Cyber</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #050510;
            overflow: hidden;
            touch-action: none;
        }

        .neon-text {
            text-shadow: 0 0 10px currentColor;
            /* Dynamic color */
        }

        .grid-cell {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
        }

        .tile {
            position: absolute;
            width: calc(25% - 0.75rem);
            height: calc(25% - 0.75rem);
            margin: 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            border-radius: 0.5rem;
            transition: all 0.15s ease-in-out;
            color: #fff;
            box-shadow: 0 0 15px currentColor;
            border: 2px solid currentColor;
        }

        .tile-new {
            animation: popIn 0.2s;
        }

        .tile-merged {
            animation: bump 0.2s;
        }

        @keyframes popIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes bump {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        /* Tile Colors (Dynamic CSS vars or classes could work, but using inline for simplicity) */
    </style>
</head>

<body class="h-screen flex flex-col items-center justify-center">

    <!-- Header -->
    <div class="w-full max-w-md flex justify-between items-end mb-8 px-4">
        <div>
            <h1 class="text-4xl text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 font-bold"
                style="text-shadow: 0 0 20px rgba(59,130,246,0.5)">2048</h1>
            <div class="text-blue-200 text-xs tracking-widest">CYBER EDITION</div>
        </div>
        <div class="bg-gray-900 border border-blue-500/50 rounded-lg px-4 py-2 text-center">
            <div class="text-blue-400 text-xs">SCORE</div>
            <div id="score" class="text-2xl text-white font-bold">0</div>
        </div>
    </div>

    <!-- Game Container -->
    <div
        class="relative bg-gray-900/80 p-3 rounded-xl border border-blue-500 shadow-2xl shadow-blue-900/50 w-full max-w-md aspect-square mx-4">

        <!-- Background Grid -->
        <div class="w-full h-full grid grid-cols-4 grid-rows-4 gap-3">
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
        </div>

        <!-- Tiles Layer -->
        <div id="tile-container" class="absolute inset-0 p-3">
            <!-- Tiles go here -->
        </div>

        <!-- Game Over Overlay -->
        <div id="game-over"
            class="absolute inset-0 bg-black/80 backdrop-blur-sm rounded-xl z-20 flex flex-col items-center justify-center hidden">
            <h2 class="text-4xl font-bold text-white mb-2">GAME OVER</h2>
            <button onclick="startGame()"
                class="mt-4 bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-8 rounded-full shadow-lg shadow-blue-500/50 transition-all transform hover:scale-105">
                TRY AGAIN
            </button>
        </div>
    </div>

    <!-- Mobile D-Pad Controls - 手機操作按鈕 -->
    <div id="mobile-controls" class="hidden mt-6 w-full max-w-md px-4">
        <div class="flex flex-col items-center gap-2">
            <!-- Up Button -->
            <button onclick="move(0)"
                class="d-pad-btn w-20 h-20 bg-blue-900/50 border-2 border-blue-500/50 rounded-xl flex items-center justify-center text-3xl text-blue-400 active:bg-blue-600/50 active:scale-95 transition-all">
                ▲
            </button>
            <!-- Left, Down, Right Row -->
            <div class="flex gap-2">
                <button onclick="move(3)"
                    class="d-pad-btn w-20 h-20 bg-blue-900/50 border-2 border-blue-500/50 rounded-xl flex items-center justify-center text-3xl text-blue-400 active:bg-blue-600/50 active:scale-95 transition-all">
                    ◀
                </button>
                <button onclick="move(2)"
                    class="d-pad-btn w-20 h-20 bg-blue-900/50 border-2 border-blue-500/50 rounded-xl flex items-center justify-center text-3xl text-blue-400 active:bg-blue-600/50 active:scale-95 transition-all">
                    ▼
                </button>
                <button onclick="move(1)"
                    class="d-pad-btn w-20 h-20 bg-blue-900/50 border-2 border-blue-500/50 rounded-xl flex items-center justify-center text-3xl text-blue-400 active:bg-blue-600/50 active:scale-95 transition-all">
                    ▶
                </button>
            </div>
        </div>
        <p class="text-center text-blue-400/50 text-xs mt-3">Tap buttons or swipe to move</p>
    </div>

    <div class="mt-4 text-gray-500 text-sm hidden md:block">
        ⌨️ Arrow Keys to Move
    </div>

    <script>
        const container = document.getElementById('tile-container');
        const scoreDisplay = document.getElementById('score');
        const gameOverScreen = document.getElementById('game-over');
        const mobileControls = document.getElementById('mobile-controls');

        // 檢測觸控裝置並顯示 D-Pad
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            mobileControls.classList.remove('hidden');
            mobileControls.classList.add('flex', 'flex-col', 'items-center');
        }

        const SIZE = 4;
        let grid = [];
        let score = 0;

        const COLORS = {
            2: '#3b82f6',    // Blue
            4: '#8b5cf6',    // Violet
            8: '#ec4899',    // Pink
            16: '#f43f5e',   // Rose
            32: '#f97316',   // Orange
            64: '#eab308',   // Yellow
            128: '#22c55e',  // Green
            256: '#06b6d4',  // Cyan
            512: '#6366f1',  // Indigo
            1024: '#d946ef', // Fuchsia
            2048: '#fff'     // White
        };

        function startGame() {
            grid = Array(SIZE).fill().map(() => Array(SIZE).fill(0));
            score = 0;
            scoreDisplay.innerText = 0;
            gameOverScreen.classList.add('hidden');
            container.innerHTML = '';

            spawnTile();
            spawnTile();
            draw();
        }

        function spawnTile() {
            const emptyCells = [];
            for (let r = 0; r < SIZE; r++)
                for (let c = 0; c < SIZE; c++)
                    if (grid[r][c] === 0) emptyCells.push({ r, c });

            if (emptyCells.length > 0) {
                const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                grid[r][c] = Math.random() < 0.9 ? 2 : 4;
                return { r, c }; // Return pos for animation if needed
            }
            return null;
        }

        function draw() {
            container.innerHTML = '';
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const val = grid[r][c];
                    if (val === 0) continue;

                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    // Position: 0 -> 0%, 1 -> 25%, etc maps to CSS grid logic?
                    // We used absolute positioning logic in CSS: width = 25% - margin.
                    // So left = c * 25%, top = r * 25%
                    tile.style.left = (c * 25) + '%';
                    tile.style.top = (r * 25) + '%';

                    const color = COLORS[val] || '#fff';
                    tile.style.color = color;
                    tile.style.backgroundColor = 'rgba(0,0,0,0.5)';
                    tile.innerText = val;

                    // Font size scaling
                    if (val > 100) tile.style.fontSize = '1.5rem';
                    if (val > 1000) tile.style.fontSize = '1.2rem';

                    container.appendChild(tile);
                }
            }
        }

        // Logic
        function move(dir) {
            // 0: Up, 1: Right, 2: Down, 3: Left
            let moved = false;
            let combinedScore = 0;

            const rotate = (matrix) => matrix[0].map((val, index) => matrix.map(row => row[index]).reverse());
            const reverse = (row) => [...row].reverse();

            // Normalize to "Left" move logic
            let tempGrid = grid.map(row => [...row]);

            // Rotate grid so we always process "Left"
            for (let i = 0; i < dir; i++) tempGrid = rotate(tempGrid); // Wait, rotation logic depends on direction mapping.
            // Up (0): Rotate Left 1? No.
            // Let's implement standard sliding vectors.

            // Re-implement simpler vectors
            const vectors = {
                0: { x: 0, y: -1 }, // Up
                1: { x: 1, y: 0 },  // Right
                2: { x: 0, y: 1 },  // Down
                3: { x: -1, y: 0 }  // Left
            };
            const vector = vectors[dir];

            let traversals = { x: [], y: [] };
            for (let pos = 0; pos < SIZE; pos++) {
                traversals.x.push(pos);
                traversals.y.push(pos);
            }

            // Always traverse from furthest cell in direction of movement?
            // Right (1): x decreases? No, traverse from right to left to avoid double merge issues?
            if (vector.x === 1) traversals.x = traversals.x.reverse();
            if (vector.y === 1) traversals.y = traversals.y.reverse();

            let merged = Array(SIZE).fill().map(() => Array(SIZE).fill(false));

            traversals.x.forEach(x => {
                traversals.y.forEach(y => {
                    const cell = { x, y };
                    const tile = grid[y][x];

                    if (tile) {
                        let far = findFarthestPosition(cell, vector);
                        let next = getCellContent({ x: far.x + vector.x, y: far.y + vector.y }); // Next cell logic?

                        // Check merge
                        // getCellContent returns null if out of bounds
                        // wait, findFarthestPosition finds the empty slot.
                        // We check the neighbor of that slot.

                        let nextPos = { x: far.x + vector.x, y: far.y + vector.y };
                        // Boundary check
                        if (nextPos.x >= 0 && nextPos.x < SIZE && nextPos.y >= 0 && nextPos.y < SIZE) {
                            const nextVal = grid[nextPos.y][nextPos.x];
                            if (nextVal === tile && !merged[nextPos.y][nextPos.x]) {
                                // MERGE
                                grid[nextPos.y][nextPos.x] *= 2;
                                grid[y][x] = 0;
                                merged[nextPos.y][nextPos.x] = true;
                                score += grid[nextPos.y][nextPos.x];
                                moved = true;
                                return;
                            }
                        }

                        // Move to furthest
                        if (far.x !== x || far.y !== y) {
                            grid[far.y][far.x] = tile;
                            grid[y][x] = 0;
                            moved = true;
                        }
                    }
                });
            });

            if (moved) {
                spawnTile();
                draw();
                scoreDisplay.innerText = score;
                if (isGameOver()) {
                    gameOverScreen.classList.remove('hidden');
                }
            }
        }

        function findFarthestPosition(cell, vector) {
            let previous;
            do {
                previous = cell;
                cell = { x: previous.x + vector.x, y: previous.y + vector.y };
            } while (
                cell.x >= 0 && cell.x < SIZE &&
                cell.y >= 0 && cell.y < SIZE &&
                grid[cell.y][cell.x] === 0
            );
            return previous;
        }

        function isGameOver() {
            // Check empty
            for (let r = 0; r < SIZE; r++)
                for (let c = 0; c < SIZE; c++)
                    if (grid[r][c] === 0) return false;

            // Check matches
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const val = grid[r][c];
                    if (c < SIZE - 1 && grid[r][c + 1] === val) return false;
                    if (r < SIZE - 1 && grid[r + 1][c] === val) return false;
                }
            }
            return true;
        }

        // Input
        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp') move(0);
            else if (e.key === 'ArrowRight') move(1);
            else if (e.key === 'ArrowDown') move(2);
            else if (e.key === 'ArrowLeft') move(3);
        });

        // Swipe
        let touchStart = { x: 0, y: 0 };
        document.addEventListener('touchstart', e => {
            touchStart.x = e.touches[0].clientX;
            touchStart.y = e.touches[0].clientY;
        }, { passive: false });

        document.addEventListener('touchend', e => {
            if (gameOverScreen.classList.contains('hidden') === false) return;
            e.preventDefault(); // Prevent scroll
            const dx = e.changedTouches[0].clientX - touchStart.x;
            const dy = e.changedTouches[0].clientY - touchStart.y;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > 30) move(dx > 0 ? 1 : 3);
            } else {
                if (Math.abs(dy) > 30) move(dy > 0 ? 2 : 0);
            }
        }, { passive: false });

        startGame();
    </script>
</body>

</html>