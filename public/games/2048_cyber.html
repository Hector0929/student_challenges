<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 Cyber</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #050510;
            overflow: hidden;
            touch-action: none;
        }

        .neon-text {
            text-shadow: 0 0 10px currentColor;
            /* Dynamic color */
        }

        .grid-cell {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
        }

        .tile {
            position: absolute;
            width: calc(25% - 0.75rem);
            height: calc(25% - 0.75rem);
            margin: 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            border-radius: 0.5rem;
            transition: all 0.15s ease-in-out;
            color: #fff;
            box-shadow: 0 0 15px currentColor;
            border: 2px solid currentColor;
        }

        .tile-new {
            animation: popIn 0.2s;
        }

        .tile-merged {
            animation: bump 0.2s;
        }

        @keyframes popIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes bump {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        /* Tile Colors (Dynamic CSS vars or classes could work, but using inline for simplicity) */
    </style>
</head>

<body class="h-screen flex flex-col items-center justify-center">

    <!-- Header -->
    <div class="w-full max-w-md flex justify-between items-end mb-8 px-4">
        <div>
            <h1 class="text-4xl text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 font-bold"
                style="text-shadow: 0 0 20px rgba(59,130,246,0.5)">2048</h1>
            <div class="text-blue-200 text-xs tracking-widest">CYBER EDITION</div>
        </div>
        <div class="bg-gray-900 border border-blue-500/50 rounded-lg px-4 py-2 text-center">
            <div class="text-blue-400 text-xs">SCORE</div>
            <div id="score" class="text-2xl text-white font-bold">0</div>
        </div>
    </div>

    <!-- Game Container -->
    <div
        class="relative bg-gray-900/80 p-3 rounded-xl border border-blue-500 shadow-2xl shadow-blue-900/50 w-full max-w-md aspect-square mx-4">

        <!-- Background Grid -->
        <div class="w-full h-full grid grid-cols-4 grid-rows-4 gap-3">
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
        </div>

        <!-- Tiles Layer -->
        <div id="tile-container" class="absolute inset-0 p-3">
            <!-- Tiles go here -->
        </div>

        <!-- Game Over Overlay -->
        <div id="game-over"
            class="absolute inset-0 bg-black/80 backdrop-blur-sm rounded-xl z-20 flex flex-col items-center justify-center hidden">
            <h2 class="text-4xl font-bold text-white mb-2">GAME OVER</h2>
            <button onclick="startGame()"
                class="mt-4 bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-8 rounded-full shadow-lg shadow-blue-500/50 transition-all transform hover:scale-105">
                TRY AGAIN
            </button>
        </div>
    </div>

    <!-- Mobile D-Pad Controls - 手機操作按鈕 -->
    <div id="mobile-controls" class="hidden mt-6 w-full max-w-md px-4">
        <div class="flex flex-col items-center gap-2">
            <!-- Up Button -->
            <button onclick="move(0)"
                class="d-pad-btn w-20 h-20 bg-blue-900/50 border-2 border-blue-500/50 rounded-xl flex items-center justify-center text-3xl text-blue-400 active:bg-blue-600/50 active:scale-95 transition-all">
                ▲
            </button>
            <!-- Left, Down, Right Row -->
            <div class="flex gap-2">
                <button onclick="move(3)"
                    class="d-pad-btn w-20 h-20 bg-blue-900/50 border-2 border-blue-500/50 rounded-xl flex items-center justify-center text-3xl text-blue-400 active:bg-blue-600/50 active:scale-95 transition-all">
                    ◀
                </button>
                <button onclick="move(2)"
                    class="d-pad-btn w-20 h-20 bg-blue-900/50 border-2 border-blue-500/50 rounded-xl flex items-center justify-center text-3xl text-blue-400 active:bg-blue-600/50 active:scale-95 transition-all">
                    ▼
                </button>
                <button onclick="move(1)"
                    class="d-pad-btn w-20 h-20 bg-blue-900/50 border-2 border-blue-500/50 rounded-xl flex items-center justify-center text-3xl text-blue-400 active:bg-blue-600/50 active:scale-95 transition-all">
                    ▶
                </button>
            </div>
        </div>
        <p class="text-center text-blue-400/50 text-xs mt-3">Tap buttons or swipe to move</p>
    </div>

    <div class="mt-4 text-gray-500 text-sm hidden md:block">
        ⌨️ Arrow Keys to Move
    </div>

    <script>
        const container = document.getElementById('tile-container');
        const scoreDisplay = document.getElementById('score');
        const gameOverScreen = document.getElementById('game-over');
        const mobileControls = document.getElementById('mobile-controls');

        // 檢測觸控裝置並顯示 D-Pad
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            mobileControls.classList.remove('hidden');
            mobileControls.classList.add('flex', 'flex-col', 'items-center');
        }

        const SIZE = 4;
        let grid = []; // Now stores tile objects: { value, id, r, c, merged }
        let score = 0;
        let tilesMap = new Map(); // Track DOM elements by ID

        const COLORS = {
            2: '#3b82f6',    // Blue
            4: '#8b5cf6',    // Violet
            8: '#ec4899',    // Pink
            16: '#f43f5e',   // Rose
            32: '#f97316',   // Orange
            64: '#eab308',   // Yellow
            128: '#22c55e',  // Green
            256: '#06b6d4',  // Cyan
            512: '#6366f1',  // Indigo
            1024: '#d946ef', // Fuchsia
            2048: '#fff'     // White
        };

        function createTileObject(val, r, c) {
            return {
                value: val,
                id: Date.now() + Math.random().toString(36).substr(2, 9),
                r: r,
                c: c,
                merged: false
            };
        }

        function startGame() {
            grid = Array(SIZE).fill().map(() => Array(SIZE).fill(null));
            score = 0;
            scoreDisplay.innerText = 0;
            gameOverScreen.classList.add('hidden');
            container.innerHTML = '';
            tilesMap.clear();

            spawnTile();
            spawnTile();
            draw();
        }

        function spawnTile() {
            const emptyCells = [];
            for (let r = 0; r < SIZE; r++)
                for (let c = 0; c < SIZE; c++)
                    if (!grid[r][c]) emptyCells.push({ r, c });

            if (emptyCells.length > 0) {
                const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                grid[r][c] = createTileObject(Math.random() < 0.9 ? 2 : 4, r, c);
                return grid[r][c];
            }
            return null;
        }

        function draw() {
            const currentIds = new Set();

            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const tileObj = grid[r][c];
                    if (!tileObj) continue;

                    currentIds.add(tileObj.id);
                    let tileDom = tilesMap.get(tileObj.id);

                    if (!tileDom) {
                        // Create NEW DOM
                        tileDom = document.createElement('div');
                        tileDom.className = 'tile tile-new';
                        tileDom.style.color = COLORS[tileObj.value] || '#fff';
                        tileDom.style.backgroundColor = 'rgba(0,0,0,0.5)';
                        tileDom.innerText = tileObj.value;
                        container.appendChild(tileDom);
                        tilesMap.set(tileObj.id, tileDom);
                    } else {
                        // Update EXISTING DOM
                        tileDom.innerText = tileObj.value;
                        tileDom.style.color = COLORS[tileObj.value] || '#fff';
                        if (tileObj.merged) {
                            tileDom.classList.add('tile-merged');
                            setTimeout(() => tileDom.classList.remove('tile-merged'), 200);
                            tileObj.merged = false;
                        }
                    }

                    // Update Position (Transition handles the glide)
                    tileDom.style.left = (c * 25) + '%';
                    tileDom.style.top = (r * 25) + '%';

                    // Font size scaling
                    if (tileObj.value > 100) tileDom.style.fontSize = '1.5rem';
                    if (tileObj.value > 1000) tileDom.style.fontSize = '1.2rem';
                }
            }

            // Remove tiles that are no longer in the grid (merged tiles)
            for (let [id, dom] of tilesMap.entries()) {
                if (!currentIds.has(id)) {
                    dom.classList.add('opacity-0', 'scale-50');
                    setTimeout(() => {
                        if (dom.parentNode) dom.parentNode.removeChild(dom);
                    }, 150);
                    tilesMap.delete(id);
                }
            }
        }

        function move(dir) {
            let moved = false;
            const vectors = {
                0: { r: -1, c: 0 }, // Up
                1: { r: 0, c: 1 },  // Right
                2: { r: 1, c: 0 },  // Down
                3: { r: 0, c: -1 }  // Left
            };
            const vector = vectors[dir];

            let rowOrder = dir === 2 ? [3, 2, 1, 0] : [0, 1, 2, 3];
            let colOrder = dir === 1 ? [3, 2, 1, 0] : [0, 1, 2, 3];

            // Reset merged status for all tiles before moving
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    if (grid[r][c]) grid[r][c].merged = false;
                }
            }

            rowOrder.forEach(r => {
                colOrder.forEach(c => {
                    const tile = grid[r][c];
                    if (!tile) return;

                    let nextR = r;
                    let nextC = c;

                    // Find farthest empty position
                    while (true) {
                        const tr = nextR + vector.r;
                        const tc = nextC + vector.c;
                        if (tr >= 0 && tr < SIZE && tc >= 0 && tc < SIZE && !grid[tr][tc]) {
                            nextR = tr;
                            nextC = tc;
                        } else {
                            break;
                        }
                    }

                    // Check if merge is possible with the neighbor after the furthest empty cell
                    const mr = nextR + vector.r;
                    const mc = nextC + vector.c;
                    if (mr >= 0 && mr < SIZE && mc >= 0 && mc < SIZE) {
                        const neighbor = grid[mr][mc];
                        if (neighbor && neighbor.value === tile.value && !neighbor.merged) {
                            // Merge!
                            neighbor.value *= 2;
                            neighbor.merged = true;
                            score += neighbor.value;
                            grid[r][c] = null;
                            moved = true;
                            return;
                        }
                    }

                    // If not merged, move to furthest empty cell
                    if (nextR !== r || nextC !== c) {
                        grid[nextR][nextC] = tile;
                        grid[r][c] = null;
                        tile.r = nextR;
                        tile.c = nextC;
                        moved = true;
                    }
                });
            });

            if (moved) {
                spawnTile();
                draw();
                scoreDisplay.innerText = score;
                if (isGameOver()) {
                    gameOverScreen.classList.remove('hidden');
                }
            }
        }

        function isGameOver() {
            // Check empty
            for (let r = 0; r < SIZE; r++)
                for (let c = 0; c < SIZE; c++)
                    if (!grid[r][c]) return false;

            // Check possible merges
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const val = grid[r][c].value;
                    if (c < SIZE - 1 && grid[r][c + 1].value === val) return false;
                    if (r < SIZE - 1 && grid[r + 1][c].value === val) return false;
                }
            }
            return true;
        }

        // Input
        document.addEventListener('keydown', e => {
            if (['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft'].includes(e.key)) {
                e.preventDefault(); // Prevent page scroll
                if (e.key === 'ArrowUp') move(0);
                else if (e.key === 'ArrowRight') move(1);
                else if (e.key === 'ArrowDown') move(2);
                else if (e.key === 'ArrowLeft') move(3);
            }
        });

        // Swipe
        let touchStart = { x: 0, y: 0 };
        document.addEventListener('touchstart', e => {
            touchStart.x = e.touches[0].clientX;
            touchStart.y = e.touches[0].clientY;
        }, { passive: false });

        document.addEventListener('touchend', e => {
            if (!gameOverScreen.classList.contains('hidden')) return;
            const dx = e.changedTouches[0].clientX - touchStart.x;
            const dy = e.changedTouches[0].clientY - touchStart.y;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > 30) move(dx > 0 ? 1 : 3);
            } else {
                if (Math.abs(dy) > 30) move(dy > 0 ? 2 : 0);
            }
        }, { passive: false });

        startGame();
    </script>
</body>

</html>