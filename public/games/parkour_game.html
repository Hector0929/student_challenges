<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon City Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            touch-action: none;
            background-color: #0f0b1e;
        }

        .neon-text {
            text-shadow: 0 0 10px #a855f7, 0 0 20px #a855f7, 0 0 40px #a855f7;
        }

        .neon-border {
            box-shadow: 0 0 10px #a855f7, inset 0 0 10px #a855f7;
        }

        .clay-btn {
            background: linear-gradient(145deg, #1e1b4b, #312e81);
            border: 1px solid #6366f1;
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.5);
            transition: all 0.2s;
        }

        .clay-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 25px rgba(99, 102, 241, 0.8);
        }

        .clay-btn:active {
            transform: scale(0.95);
        }

        canvas {
            image-rendering: pixelated;
        }
    </style>
</head>

<body class="h-screen flex flex-col items-center justify-center select-none" oncontextmenu="return false;">

    <!-- UI Overlay -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-6 z-10">
        <!-- Score -->
        <div class="flex justify-between items-start">
            <div
                class="bg-black/50 backdrop-blur rounded-xl px-6 py-2 border-2 border-purple-500 shadow-lg neon-border">
                <span class="text-2xl text-purple-400">SCORE</span>
                <span id="score" class="text-3xl text-white font-bold ml-4">0</span>
            </div>
            <div id="hint-text" class="text-white/70 animate-pulse text-sm text-right bg-black/30 p-2 rounded">
                [SPACE] Jump / Double Jump<br>
                Collect STARS for bonus!
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 z-20 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div
            class="bg-gray-900 rounded-2xl p-8 text-center max-w-sm mx-4 border-2 border-purple-500 shadow-2xl neon-border pointer-events-auto">
            <div class="text-6xl mb-4 animate-bounce">üèÉüí®</div>
            <h1
                class="text-4xl text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600 font-bold mb-2 neon-text">
                NEON RUNNER</h1>
            <p class="text-purple-300 mb-8 tracking-wider">CYBERPUNK CITY CHALLENGE</p>
            <button onclick="startGame()" class="clay-btn text-white px-8 py-4 text-xl font-bold w-full rounded-xl">
                START MISSION
            </button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen"
        class="hidden absolute inset-0 z-20 flex items-center justify-center bg-red-900/90 backdrop-blur-md">
        <div
            class="bg-gray-900 rounded-2xl p-8 text-center max-w-sm mx-4 border-2 border-red-500 shadow-2xl pointer-events-auto">
            <div class="text-6xl mb-4">üíÄ</div>
            <h2 class="text-3xl text-red-500 font-bold mb-2 text-shadow-red">CRASHED!</h2>
            <div class="text-gray-400 mb-6 text-lg">
                FINAL SCORE<br>
                <span id="final-score" class="font-bold text-white text-4xl">0</span>
            </div>
            <button onclick="resetGame()"
                class="clay-btn text-white px-8 py-3 w-full text-lg rounded-xl border-red-500 hover:shadow-red-500/50">
                RETRY
            </button>
        </div>
    </div>

    <canvas id="gameCanvas" class="w-full h-full"></canvas>

    <script>
        /**
         * NEON CITY RUNNER
         * Redesigned with:
         * 1. Parallax Backgrounds
         * 2. Squash & Stretch Physics
         * 3. Progressive Difficulty
         * 4. Particle Systems
         * 5. Object Pooling (Basic)
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Configuration ---
        const CONFIG = {
            gravity: 0.6,
            jumpForce: -12,
            initialSpeed: 6,
            maxSpeed: 15,
            floorHeight: 120,
            colors: {
                bg: '#0f0b1e',
                floor: '#1a1625',
                floorLine: '#a855f7',
                player: '#22d3ee',
                playerGlow: '#06b6d4',
                obstacle: '#f43f5e',
                star: '#fbbf24'
            }
        };

        // --- State ---
        let state = {
            isPlaying: false,
            score: 0,
            speed: CONFIG.initialSpeed,
            frame: 0,
            distance: 0,
            cameraShake: 0
        };

        // --- Classes ---

        class Particle {
            constructor(x, y, color, speed, size, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.size = size;
                this.life = life;
                this.maxLife = life;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                this.size *= 0.95;
            }

            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        class Star {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.collected = false;
                this.angle = 0;
            }

            update() {
                this.x -= state.speed;
                this.angle += 0.1;
                this.y += Math.sin(this.angle) * 0.5; // Float
            }

            draw(ctx) {
                if (this.collected) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                ctx.shadowBlur = 15;
                ctx.shadowColor = CONFIG.colors.star;
                ctx.fillStyle = CONFIG.colors.star;

                // Draw Star Shape
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(Math.cos((18 + i * 72) * 0.01745) * 10, -Math.sin((18 + i * 72) * 0.01745) * 10);
                    ctx.lineTo(Math.cos((54 + i * 72) * 0.01745) * 4, -Math.sin((54 + i * 72) * 0.01745) * 4);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        class Player {
            constructor() {
                this.w = 40;
                this.h = 40;
                this.x = 100;
                this.y = 0;
                this.vy = 0;
                this.isGrounded = false;
                this.jumpCount = 0;
                this.rotation = 0;

                // Squash & Stretch
                this.scaleX = 1;
                this.scaleY = 1;
            }

            reset() {
                this.y = canvas.height - CONFIG.floorHeight - this.h;
                this.vy = 0;
                this.jumpCount = 0;
                this.rotation = 0;
                this.scaleX = 1;
                this.scaleY = 1;
            }

            jump() {
                if (this.isGrounded) {
                    this.vy = CONFIG.jumpForce;
                    this.isGrounded = false;
                    this.jumpCount = 1;

                    // Stretch on jump
                    this.scaleX = 0.7;
                    this.scaleY = 1.3;

                    spawnParticles(this.x + this.w / 2, this.y + this.h, 10, '#fff');
                    playSound('jump');
                } else if (this.jumpCount < 2) {
                    this.vy = CONFIG.jumpForce * 0.9;
                    this.jumpCount = 2;

                    // Spin
                    this.rotation += Math.PI;
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;

                    spawnParticles(this.x + this.w / 2, this.y + this.h, 15, CONFIG.colors.star);
                    playSound('jump_double');
                }
            }

            update() {
                // Physics
                this.vy += CONFIG.gravity;
                this.y += this.vy;

                // Ground Check
                const groundY = canvas.height - CONFIG.floorHeight - this.h;
                if (this.y >= groundY) {
                    if (!this.isGrounded) {
                        // Landed
                        this.scaleX = 1.3;
                        this.scaleY = 0.7;
                        spawnParticles(this.x + this.w / 2, this.y + this.h, 5, CONFIG.colors.floorLine);
                    }
                    this.y = groundY;
                    this.vy = 0;
                    this.isGrounded = true;
                    this.jumpCount = 0;
                    // Snap rotation
                    this.rotation = Math.round(this.rotation / (Math.PI / 2)) * (Math.PI / 2);
                } else {
                    this.rotation += 0.1;
                }

                // Return to normal scale
                this.scaleX += (1 - this.scaleX) * 0.1;
                this.scaleY += (1 - this.scaleY) * 0.1;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
                ctx.scale(this.scaleX, this.scaleY);
                ctx.rotate(this.rotation);

                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = CONFIG.colors.playerGlow;

                // Body
                ctx.fillStyle = CONFIG.colors.player;
                ctx.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);

                // Eye
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                ctx.fillRect(5, -10, 10, 10);

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.w / 2, -this.h / 2, this.w, this.h);

                ctx.restore();
            }
        }

        // --- Systems ---
        const player = new Player();
        let obstacles = [];
        let particles = [];
        let stars = [];
        let buildingLayers = []; // Parallax

        // Parallax Setup
        function initBackground() {
            buildingLayers = [
                { speed: 0.2, color: '#160f2b', buildings: [] }, // Far
                { speed: 0.5, color: '#241a42', buildings: [] }, // Mid
                { speed: 1.0, color: '#322261', buildings: [] }  // Close
            ];

            // Fill initial buildings
            buildingLayers.forEach(layer => {
                let x = 0;
                while (x < canvas.width + 200) {
                    const w = 50 + Math.random() * 100;
                    const h = 50 + Math.random() * 300;
                    layer.buildings.push({ x, w, h });
                    x += w + Math.random() * 20;
                }
            });
        }

        function updateBackground() {
            buildingLayers.forEach(layer => {
                // Update X
                layer.buildings.forEach(b => {
                    b.x -= state.speed * layer.speed;
                });

                // Wrap / Recycle
                if (layer.buildings[0].x + layer.buildings[0].w < -100) {
                    const first = layer.buildings.shift();
                    const last = layer.buildings[layer.buildings.length - 1];
                    first.x = last.x + last.w + Math.random() * 20;
                    first.h = 50 + Math.random() * 300; // Reshuffle height
                    layer.buildings.push(first);
                }
            });
        }

        function drawBackground() {
            buildingLayers.forEach(layer => {
                ctx.fillStyle = layer.color;
                layer.buildings.forEach(b => {
                    // Draw skyscraper with some "windows"
                    const floorY = canvas.height - CONFIG.floorHeight;
                    ctx.fillRect(b.x, floorY - b.h, b.w, b.h);

                    // Windows (Simple optimization: just dots)
                    // (Skipped for performance if needed, but adding simple glow)
                });
            });
        }

        // --- Main Loop ---
        function loop() {
            if (!state.isPlaying) return;

            // Update
            player.update();
            updateObstacles();
            updateStars();
            updateParticles();
            updateBackground();

            // Screen Shake Decay
            if (state.cameraShake > 0) {
                state.cameraShake *= 0.9;
                if (state.cameraShake < 0.5) state.cameraShake = 0;
            }

            // Progression
            state.distance += state.speed;
            state.speed = CONFIG.initialSpeed + (state.score / 2000); // Speed up slowly
            if (state.speed > CONFIG.maxSpeed) state.speed = CONFIG.maxSpeed;

            state.score += 1;
            document.getElementById('score').innerText = Math.floor(state.score);

            // Draw
            ctx.fillStyle = CONFIG.colors.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply Shake
            ctx.save();
            if (state.cameraShake > 0) {
                const dx = (Math.random() - 0.5) * state.cameraShake;
                const dy = (Math.random() - 0.5) * state.cameraShake;
                ctx.translate(dx, dy);
            }

            drawBackground();

            // Floor
            ctx.shadowBlur = 20;
            ctx.shadowColor = CONFIG.colors.floorLine;
            ctx.fillStyle = CONFIG.colors.floor;
            ctx.fillRect(0, canvas.height - CONFIG.floorHeight, canvas.width, CONFIG.floorHeight);

            // Neon Line
            ctx.fillStyle = CONFIG.colors.floorLine;
            ctx.fillRect(0, canvas.height - CONFIG.floorHeight, canvas.width, 4);
            ctx.shadowBlur = 0; // Reset

            player.draw(ctx);

            obstacles.forEach(drawObstacle);
            stars.forEach(s => s.draw(ctx));
            particles.forEach(p => p.draw(ctx));

            ctx.restore();

            state.frame++;
            requestAnimationFrame(loop);
        }

        // --- Advanced Classes ---

        class Platform {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.type = 'platform';
                this.passed = false;
            }

            draw(ctx) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = CONFIG.colors.playerGlow;
                ctx.fillStyle = '#4c1d95'; // Dark purple
                ctx.fillRect(this.x, this.y, this.w, this.h);

                // Neon top
                ctx.fillStyle = '#c084fc';
                ctx.fillRect(this.x, this.y, this.w, 4);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y, this.w, this.h);
                ctx.shadowBlur = 0;
            }
        }

        class Drone {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.w = 30;
                this.h = 30;
                this.vx = 8; // Faster than world
                this.type = 'drone';
                this.oscillation = Math.random() * Math.PI;
            }

            update() {
                // Move left faster (relative speed = drone.vx + state.speed effectively)
                // Actually if we want it to charge, it moves left relative to world
                this.x -= (state.speed + 3);

                // Bobbing functionality
                this.y += Math.sin(state.frame * 0.1 + this.oscillation) * 2;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.w / 2, this.y + this.h / 2);

                // Rotation effect
                ctx.rotate(state.frame * 0.2);

                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ef4444';

                // Spiky shape
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const r = (i % 2 === 0) ? 15 : 8;
                    ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                }
                ctx.closePath();
                ctx.fill();

                // Eye
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Lava {
            constructor(x, w) {
                this.x = x;
                this.y = canvas.height - CONFIG.floorHeight + 20; // Slightly below floor level
                this.w = w;
                this.h = CONFIG.floorHeight;
                this.type = 'lava';
            }

            draw(ctx) {
                // Draw over the floor
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(this.x, canvas.height - CONFIG.floorHeight, this.w, CONFIG.floorHeight);

                // Bubbles logic could go here, for now simple glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#fca5a5';
                ctx.fillStyle = '#b91c1c';
                ctx.fillRect(this.x, canvas.height - CONFIG.floorHeight + 10, this.w, CONFIG.floorHeight);
                ctx.shadowBlur = 0;
            }
        }

        // --- Player Updates for Physics ---
        // We need to inject platform collision into Player.update
        // ... (This requires modifying the Player class or the update loop) ...
        // Let's modify the update loop collision check.

        // --- Pattern Generator ---
        const PATTERNS = [
            // 0: Classic 3 spikes (Easy)
            (startX) => [
                { type: 'spike', x: startX, delay: 0 },
                { type: 'spike', x: startX + 200, delay: 0 },
                { type: 'spike', x: startX + 400, delay: 0 }
            ],
            // 1: Platform jump over lava (Medium)
            (startX) => {
                const floorY = canvas.height - CONFIG.floorHeight;
                return [
                    { type: 'platform', x: startX, y: floorY - 80, w: 100, h: 20 },
                    { type: 'lava', x: startX + 50, w: 300 }, // Dangerous floor
                    { type: 'platform', x: startX + 200, y: floorY - 120, w: 100, h: 20 },
                    { type: 'star', x: startX + 250, y: floorY - 200 }
                ];
            },
            // 2: Drone ambush (Hard) - HIGH ALTITUDE ONLY
            (startX) => {
                const floorY = canvas.height - CONFIG.floorHeight;
                return [
                    // Provide a platform to even reach the drones/star, or just make them air hazards
                    { type: 'platform', x: startX, y: floorY - 100, w: 100, h: 20 },
                    // Drones now much higher: -200 and -250 (requires jumping from platform or high jump)
                    { type: 'drone', x: startX + 300, y: floorY - 200 },
                    { type: 'drone', x: startX + 500, y: floorY - 250 },
                    { type: 'star', x: startX + 400, y: floorY - 300 }
                ];
            },
            // 3: High stairs (Medium/Hard)
            (startX) => {
                const floorY = canvas.height - CONFIG.floorHeight;
                return [
                    { type: 'platform', x: startX, y: floorY - 60, w: 80, h: 20 },
                    { type: 'platform', x: startX + 150, y: floorY - 120, w: 80, h: 20 },
                    { type: 'platform', x: startX + 300, y: floorY - 180, w: 80, h: 20 },
                    { type: 'star', x: startX + 340, y: floorY - 240 },
                    { type: 'spike', x: startX + 150, y: floorY } // Trap below
                ];
            },
            // 4: Single Spike (Training) - Very Easy
            (startX) => {
                const floorY = canvas.height - CONFIG.floorHeight;
                return [
                    { type: 'spike', x: startX, delay: 0 }
                ];
            }
        ];

        let nextSpawnX = 0;

        function updateObstacles() {
            // Spawning Logic using Patterns
            // Initialize nextSpawnX if needed
            if (nextSpawnX === 0) nextSpawnX = canvas.width;

            if (nextSpawnX < canvas.width + 100) {
                spawnPattern();
            }

            // Critical fix: Move the spawn point with the world
            if (nextSpawnX > 0) nextSpawnX -= state.speed;

            // Move container for patterns? No, we just spawn individual objects from the pattern.
            // Actually, we need to correct the 'update' of obstacles to handle the new types

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];

                if (obs.update) {
                    obs.update(); // For Drones
                } else {
                    obs.x -= state.speed;
                }

                // Collision
                if (checkCollision(player, obs)) {
                    if (obs.type === 'lava' || obs.type === 'spike' || obs.type === 'drone' || obs.type === 'tall') {
                        gameOver();
                    }
                }

                // Platform Landing Logic
                if (obs.type === 'platform') {
                    // Check if player enters from top
                    // Previous Y (approximate)
                    const prevY = player.y - player.vy;
                    if (player.vy >= 0 && // Falling
                        player.x + player.w > obs.x && player.x < obs.x + obs.w && // Horizontal overlaps
                        player.y + player.h >= obs.y && player.y + player.h <= obs.y + 20 && // Feet at top edge
                        prevY + player.h <= obs.y + 10 // Was above
                    ) {
                        player.y = obs.y - player.h;
                        player.vy = 0;
                        player.isGrounded = true;
                        player.jumpCount = 0;
                        player.rotation = Math.round(player.rotation / (Math.PI / 2)) * (Math.PI / 2);
                    }
                }

                if (obs.x + (obs.w || 30) < -200) obstacles.splice(i, 1);
            }
        }

        function updateStars() {
            for (let i = stars.length - 1; i >= 0; i--) {
                const star = stars[i];
                star.update();

                // Collect
                const dx = (player.x + player.w / 2) - star.x;
                const dy = (player.y + player.h / 2) - star.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 40) { // Collection radius
                    state.score += 500;
                    spawnParticles(star.x, star.y, 10, star.color);
                    playSound('coin');
                    stars.splice(i, 1);
                } else if (star.x < -100) {
                    stars.splice(i, 1);
                }
            }
        }

        function spawnPattern() {
            // Difficulty Progression
            let availablePatterns = [];
            let extraGap = 0;

            if (state.score < 500) {
                availablePatterns = [4]; // Just Single Spike (Training)
                extraGap = 300; // More breathing room for beginners
            } else if (state.score < 1500) {
                availablePatterns = [0, 1, 4]; // Classic Spikes + Platforms + Single
            } else {
                availablePatterns = [0, 1, 2, 3]; // All (including Drones, excluding baby pattern 4)
            }

            const patternIdx = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
            const patternFn = PATTERNS[patternIdx];

            // Space patterns out based on speed
            const gap = 500 + Math.random() * 300 + (state.speed * 20) + extraGap;

            const entities = patternFn(nextSpawnX);
            const floorY = canvas.height - CONFIG.floorHeight;

            entities.forEach(entity => {
                if (entity.type === 'spike') {
                    obstacles.push({ x: entity.x, y: floorY - 40, w: 40, h: 40, type: 'spike' });
                } else if (entity.type === 'tall') {
                    obstacles.push({ x: entity.x, y: floorY - 90, w: 30, h: 90, type: 'tall' });
                } else if (entity.type === 'platform') {
                    obstacles.push(new Platform(entity.x, entity.y, entity.w, entity.h));
                } else if (entity.type === 'drone') {
                    obstacles.push(new Drone(entity.x, entity.y));
                } else if (entity.type === 'lava') {
                    obstacles.push(new Lava(entity.x, entity.w));
                } else if (entity.type === 'star') {
                    stars.push(new Star(entity.x, entity.y));
                }
            });

            nextSpawnX += gap;
        }

        function drawObstacle(obs) {
            if (obs.draw) {
                obs.draw(ctx);
                return;
            }

            // Fallback for simple objects (spikes)
            ctx.shadowBlur = 10;
            ctx.shadowColor = CONFIG.colors.obstacle;
            ctx.fillStyle = CONFIG.colors.obstacle;

            // Draw Triangle
            ctx.beginPath();
            if (obs.type === 'tall') {
                ctx.moveTo(obs.x, obs.y + obs.h);
                ctx.lineTo(obs.x + obs.w / 2, obs.y);
                ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
            } else {
                ctx.moveTo(obs.x, obs.y + obs.h);
                ctx.lineTo(obs.x + obs.w / 2, obs.y);
                ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
            }

            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }


        function checkCollision(p, obs) {
            // Hitbox tuning (forgiving)
            const buffering = 10;
            return (
                p.x + buffering < obs.x + obs.w &&
                p.x + p.w - buffering > obs.x &&
                p.y + p.h - buffering > obs.y
            );
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function spawnParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, 5, Math.random() * 5 + 3, 1));
            }
        }

        // --- Game Flow ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (!state.isPlaying) {
                // If waiting, draw title bg maybe?
                ctx.fillStyle = CONFIG.colors.bg;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        window.addEventListener('resize', resize);

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');

            state.isPlaying = true;
            state.score = 0;
            state.speed = CONFIG.initialSpeed;
            obstacles = [];
            particles = [];
            stars = [];
            nextSpawnX = canvas.width; // Reset pattern spawner

            initBackground();
            player.reset();
            resize();
            loop();
        }

        function resetGame() {
            document.getElementById('game-over-screen').classList.add('hidden');
            startGame();
        }

        function gameOver() {
            state.isPlaying = false;
            state.cameraShake = 20; // Big shake
            playSound('hit');
            document.getElementById('final-score').innerText = Math.floor(state.score);
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('ui-layer').classList.add('hidden');
        }

        // Input
        function handleInput(e) {
            if ((e.code === 'Space' || e.code === 'ArrowUp') || e.type === 'touchstart') {
                if (state.isPlaying) player.jump();
            }
        }
        window.addEventListener('keydown', handleInput);
        window.addEventListener('touchstart', handleInput);

        // Audio
        function playSound(type) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            const ctx = new AudioContext();
            const osc = ctx.createOscillator();
            const g = ctx.createGain();
            osc.connect(g);
            g.connect(ctx.destination);

            const now = ctx.currentTime;

            if (type === 'jump') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(300, now + 0.1);
                g.gain.setValueAtTime(0.1, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start();
                osc.stop(now + 0.1);
            } else if (type === 'jump_double') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.2);
                g.gain.setValueAtTime(0.1, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start();
                osc.stop(now + 0.2);
            } else if (type === 'coin') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.setValueAtTime(1800, now + 0.1);
                g.gain.setValueAtTime(0.1, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start();
                osc.stop(now + 0.1);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
                g.gain.setValueAtTime(0.3, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.start();
                osc.stop(now + 0.5);
            }
        }

        resize();
    </script>
</body>

</html>