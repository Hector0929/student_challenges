<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Jump</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'DotGothic16', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        .clay-btn {
            border-radius: 1rem;
            box-shadow: 4px 4px 8px #d1d9e6, -4px -4px 8px #ffffff;
            transition: all 0.2s;
        }

        .clay-btn:active {
            transform: scale(0.95);
            box-shadow: inset 4px 4px 8px #d1d9e6, inset -4px -4px 8px #ffffff;
        }

        canvas {
            image-rendering: pixelated;
        }
    </style>
</head>

<body class="bg-indigo-900 h-screen flex flex-col items-center justify-center select-none"
    oncontextmenu="return false;">

    <!-- UI Overlay -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-6 z-10">
        <!-- Score -->
        <div class="flex justify-between items-start">
            <div class="bg-white/90 backdrop-blur rounded-xl px-6 py-2 border-4 border-indigo-200 shadow-lg">
                <span class="text-2xl">üèÜ</span>
                <span id="score" class="text-2xl text-indigo-900 font-bold font-mono">0</span>
            </div>
            <div id="hint-text" class="text-white/50 animate-pulse text-sm">
                ÊåâÁ©∫ÁôΩÈçµÊàñÈªûÊìäË∑≥Ë∫ç
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 z-20 flex items-center justify-center bg-black/40 backdrop-blur-sm">
        <div
            class="bg-white rounded-3xl p-8 text-center max-w-sm mx-4 border-4 border-indigo-500 shadow-2xl animate-bounce-in pointer-events-auto">
            <div class="text-8xl mb-4 animate-bounce">üî≤</div>
            <h1 class="text-4xl text-indigo-900 font-bold mb-2">ÊñπÂ°äË°ùÂà∫</h1>
            <p class="text-indigo-400 mb-8">Ë∫≤ÈÅøÂ∞ñÂà∫ÔºåË°ùÂêëÁµÇÈªûÔºÅ</p>
            <button onclick="startGame()"
                class="clay-btn bg-indigo-500 text-white px-8 py-4 text-xl font-bold hover:bg-indigo-600 block w-full">
                ÈñãÂßãÂ•îË∑ë
            </button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen"
        class="hidden absolute inset-0 z-20 flex items-center justify-center bg-red-900/80 backdrop-blur-md">
        <div
            class="bg-white rounded-3xl p-8 text-center max-w-sm mx-4 border-4 border-red-500 shadow-2xl pointer-events-auto">
            <div class="text-6xl mb-4">üí•</div>
            <h2 class="text-3xl text-red-900 font-bold mb-2">ÊíûÂà∞‰∫ÜÔºÅ</h2>
            <p class="text-gray-600 mb-6">Êú¨Ê¨°ÂæóÂàÜ: <span id="final-score" class="font-bold text-red-600 text-2xl">0</span>
            </p>
            <button onclick="resetGame()"
                class="clay-btn bg-red-500 text-white px-8 py-3 w-full text-lg hover:bg-red-600">
                ÂÜç‰æÜ‰∏ÄÊ¨°
            </button>
        </div>
    </div>

    <canvas id="gameCanvas" class="w-full h-full"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const GRAVITY = 0.6;
        const JUMP_FORCE = -10.5; // Slightly reduced jump force
        const SPEED = 5;
        const FLOOR_HEIGHT = 100;

        // Game State
        let isPlaying = false;
        let score = 0;
        let frame = 0;
        let obstacles = [];
        let particles = [];

        // Player Object
        const player = {
            x: 100,
            y: 0,
            w: 40,
            h: 40,
            vy: 0,
            isGrounded: false,
            rotation: 0,
            color: '#6366f1' // Indigo-500
        };

        // Resize Canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.y = canvas.height - FLOOR_HEIGHT - player.h;
        }
        window.addEventListener('resize', resize);
        resize();

        // Input Handling
        function jump() {
            if (!isPlaying) return;
            if (player.isGrounded) {
                player.vy = JUMP_FORCE;
                player.isGrounded = false;
                spawnParticles(player.x + player.w / 2, player.y + player.h, 5, '#e0e7ff'); // Dust
                playSound('jump');
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') jump();
        });

        window.addEventListener('pointerdown', (e) => {
            // Prevent clicking UI buttons from triggering jump
            if (e.target.tagName !== 'BUTTON') jump();
        });

        // Loop
        function loop() {
            if (!isPlaying) return;

            // Clear
            ctx.fillStyle = '#1e1b4b'; // Indigo-950
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Background Grid (Perspective effect)
            drawBackground();

            // Floor
            ctx.fillStyle = '#312e81'; // Indigo-900
            ctx.fillRect(0, canvas.height - FLOOR_HEIGHT, canvas.width, FLOOR_HEIGHT);
            // Floor highlight line
            ctx.fillStyle = '#6366f1';
            ctx.fillRect(0, canvas.height - FLOOR_HEIGHT, canvas.width, 4);

            updatePlayer();
            updateObstacles();
            updateParticles();

            drawPlayer();

            // UI Update
            score += 0.1; // Distance based score
            document.getElementById('score').innerText = Math.floor(score);

            frame++;
            requestAnimationFrame(loop);
        }

        function updatePlayer() {
            player.vy += GRAVITY;
            player.y += player.vy;

            // Ground Collision
            const floorY = canvas.height - FLOOR_HEIGHT - player.h;
            if (player.y >= floorY) {
                player.y = floorY;
                player.vy = 0;
                player.isGrounded = true;

                // Snap rotation to nearest 90 degrees when grounded
                const mod = player.rotation % (Math.PI / 2);
                if (mod < 0.1 || mod > (Math.PI / 2 - 0.1)) {
                    player.rotation = Math.round(player.rotation / (Math.PI / 2)) * (Math.PI / 2);
                } else {
                    // Auto-correct rotation if slightly off
                    player.rotation += 0.1;
                }
            } else {
                // Rotate while jumping
                player.rotation += 0.1;
            }
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
            ctx.rotate(player.rotation);

            // Draw Cube
            ctx.fillStyle = player.color;
            ctx.fillRect(-player.w / 2, -player.h / 2, player.w, player.h);

            // Inner Face
            ctx.fillStyle = '#818cf8'; // Lighter indigo
            ctx.fillRect(-player.w / 4, -player.h / 4, player.w / 2, player.h / 2);

            // Border
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(-player.w / 2, -player.h / 2, player.w, player.h);

            ctx.restore();
        }

        function updateObstacles() {
            // Spawn Spikes
            if (frame % 90 === 0) { // Approx every 1.5 seconds
                const type = Math.random() > 0.7 ? 'double' : 'single';
                const count = type === 'double' ? 2 : 1;

                for (let i = 0; i < count; i++) {
                    obstacles.push({
                        x: canvas.width + (i * 40),
                        y: canvas.height - FLOOR_HEIGHT,
                        w: 40,
                        h: 40,
                        type: 'spike'
                    });
                }
            }

            // Move & Draw Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.x -= SPEED;

                // Draw Spike
                ctx.fillStyle = '#f43f5e'; // Rose-500
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(obs.x, obs.y);
                ctx.lineTo(obs.x + obs.w / 2, obs.y - obs.h);
                ctx.lineTo(obs.x + obs.w, obs.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Collision Detection (Simple Box for player vs Triangle tip)
                // Tip of triangle is hazardous
                const tipX = obs.x + obs.w / 2;
                const tipY = obs.y - obs.h + 10; // Slightly forgiving

                if (
                    player.x < tipX + 10 &&
                    player.x + player.w > tipX - 10 &&
                    player.y + player.h > tipY
                ) {
                    gameOver();
                }

                // Remove off-screen
                if (obs.x + obs.w < 0) {
                    obstacles.splice(i, 1);
                }
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                p.size *= 0.9;

                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1;

                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function spawnParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1.0,
                    size: Math.random() * 8 + 4,
                    color: color
                });
            }
        }

        function drawBackground() {
            // Moving Grid
            ctx.strokeStyle = '#4338ca'; // Indigo-800
            ctx.lineWidth = 1;
            const gridSize = 100;
            const offset = (frame * SPEED * 0.5) % gridSize;

            // Verticals
            for (let x = -offset; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            // Horizontals
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function gameOver() {
            isPlaying = false;
            playSound('hit');
            spawnParticles(player.x + player.w / 2, player.y + player.h / 2, 30, '#f43f5e');
            document.getElementById('final-score').innerText = Math.floor(score);
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('ui-layer').classList.add('hidden');
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            document.getElementById('hint-text').classList.remove('hidden');
            setTimeout(() => document.getElementById('hint-text').classList.add('hidden'), 3000);

            resetGameLogic();
        }

        function resetGame() {
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            resetGameLogic();
        }

        function resetGameLogic() {
            score = 0;
            frame = 0;
            obstacles = [];
            particles = [];
            player.y = canvas.height - FLOOR_HEIGHT - player.h;
            player.vy = 0;
            player.rotation = 0;
            isPlaying = true;
            loop();
        }

        function playSound(type) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            const ctx = new AudioContext();
            const osc = ctx.createOscillator();
            const g = ctx.createGain();
            osc.connect(g);
            g.connect(ctx.destination);

            if (type === 'jump') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(300, ctx.currentTime + 0.1);
                g.gain.setValueAtTime(0.1, ctx.currentTime);
                g.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.start();
                osc.stop(ctx.currentTime + 0.1);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, ctx.currentTime + 0.3);
                g.gain.setValueAtTime(0.2, ctx.currentTime);
                g.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                osc.start();
                osc.stop(ctx.currentTime + 0.3);
            }
        }

    </script>
</body>

</html>