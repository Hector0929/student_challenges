<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon City Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            touch-action: none;
            background-color: #0f0b1e;
        }

        .neon-text {
            text-shadow: 0 0 10px #a855f7, 0 0 20px #a855f7, 0 0 40px #a855f7;
        }

        .neon-border {
            box-shadow: 0 0 10px #a855f7, inset 0 0 10px #a855f7;
        }

        .clay-btn {
            background: linear-gradient(145deg, #1e1b4b, #312e81);
            border: 1px solid #6366f1;
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.5);
            transition: all 0.2s;
        }

        .clay-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 25px rgba(99, 102, 241, 0.8);
        }

        .clay-btn:active {
            transform: scale(0.95);
        }

        canvas {
            image-rendering: pixelated;
        }
    </style>
</head>

<body class="h-screen flex flex-col items-center justify-center select-none" oncontextmenu="return false;">

    <!-- UI Overlay -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-6 z-10">
        <!-- Score -->
        <div class="flex justify-between items-start">
            <div
                class="bg-black/50 backdrop-blur rounded-xl px-6 py-2 border-2 border-purple-500 shadow-lg neon-border">
                <span class="text-2xl text-purple-400">SCORE</span>
                <span id="score" class="text-3xl text-white font-bold ml-4">0</span>
            </div>
            <div id="hint-text" class="text-white/70 animate-pulse text-sm text-right bg-black/30 p-2 rounded">
                [SPACE] Jump / Double Jump<br>
                Collect STARS for bonus!
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 z-20 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div
            class="bg-gray-900 rounded-2xl p-8 text-center max-w-sm mx-4 border-2 border-purple-500 shadow-2xl neon-border pointer-events-auto">
            <div class="text-6xl mb-4 animate-bounce">üèÉüí®</div>
            <h1
                class="text-4xl text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600 font-bold mb-2 neon-text">
                NEON RUNNER</h1>
            <p class="text-purple-300 mb-8 tracking-wider">CYBERPUNK CITY CHALLENGE</p>
            <button onclick="startGame()" class="clay-btn text-white px-8 py-4 text-xl font-bold w-full rounded-xl">
                START MISSION
            </button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen"
        class="hidden absolute inset-0 z-20 flex items-center justify-center bg-red-900/90 backdrop-blur-md">
        <div
            class="bg-gray-900 rounded-2xl p-8 text-center max-w-sm mx-4 border-2 border-red-500 shadow-2xl pointer-events-auto">
            <div class="text-6xl mb-4">üíÄ</div>
            <h2 class="text-3xl text-red-500 font-bold mb-2 text-shadow-red">CRASHED!</h2>
            <div class="text-gray-400 mb-6 text-lg">
                FINAL SCORE<br>
                <span id="final-score" class="font-bold text-white text-4xl">0</span>
            </div>
            <button onclick="resetGame()"
                class="clay-btn text-white px-8 py-3 w-full text-lg rounded-xl border-red-500 hover:shadow-red-500/50">
                RETRY
            </button>
        </div>
    </div>

    <canvas id="gameCanvas" class="w-full h-full"></canvas>

    <script>
        /**
         * NEON CITY RUNNER
         * Redesigned with:
         * 1. Parallax Backgrounds
         * 2. Squash & Stretch Physics
         * 3. Progressive Difficulty
         * 4. Particle Systems
         * 5. Object Pooling (Basic)
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Configuration ---
        const CONFIG = {
            gravity: 0.6,
            jumpForce: -12,
            initialSpeed: 6,
            maxSpeed: 15,
            floorHeight: 120,
            colors: {
                bg: '#0f0b1e',
                floor: '#1a1625',
                floorLine: '#a855f7',
                player: '#22d3ee',
                playerGlow: '#06b6d4',
                obstacle: '#f43f5e',
                star: '#fbbf24'
            }
        };

        // --- State ---
        let state = {
            isPlaying: false,
            score: 0,
            speed: CONFIG.initialSpeed,
            frame: 0,
            distance: 0,
            cameraShake: 0
        };

        // --- Classes ---

        class Particle {
            constructor(x, y, color, speed, size, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.size = size;
                this.life = life;
                this.maxLife = life;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                this.size *= 0.95;
            }

            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        class Star {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.collected = false;
                this.angle = 0;
            }

            update() {
                this.x -= state.speed;
                this.angle += 0.1;
                this.y += Math.sin(this.angle) * 0.5; // Float
            }

            draw(ctx) {
                if (this.collected) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                ctx.shadowBlur = 15;
                ctx.shadowColor = CONFIG.colors.star;
                ctx.fillStyle = CONFIG.colors.star;

                // Draw Star Shape
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(Math.cos((18 + i * 72) * 0.01745) * 10, -Math.sin((18 + i * 72) * 0.01745) * 10);
                    ctx.lineTo(Math.cos((54 + i * 72) * 0.01745) * 4, -Math.sin((54 + i * 72) * 0.01745) * 4);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        class Player {
            constructor() {
                this.w = 40;
                this.h = 40;
                this.x = 100;
                this.y = 0;
                this.vy = 0;
                this.isGrounded = false;
                this.jumpCount = 0;
                this.rotation = 0;

                // Squash & Stretch
                this.scaleX = 1;
                this.scaleY = 1;
            }

            reset() {
                this.y = canvas.height - CONFIG.floorHeight - this.h;
                this.vy = 0;
                this.jumpCount = 0;
                this.rotation = 0;
                this.scaleX = 1;
                this.scaleY = 1;
            }

            jump() {
                if (this.isGrounded) {
                    this.vy = CONFIG.jumpForce;
                    this.isGrounded = false;
                    this.jumpCount = 1;

                    // Stretch on jump
                    this.scaleX = 0.7;
                    this.scaleY = 1.3;

                    spawnParticles(this.x + this.w / 2, this.y + this.h, 10, '#fff');
                    playSound('jump');
                } else if (this.jumpCount < 2) {
                    this.vy = CONFIG.jumpForce * 0.9;
                    this.jumpCount = 2;

                    // Spin
                    this.rotation += Math.PI;
                    this.scaleX = 0.8;
                    this.scaleY = 1.2;

                    spawnParticles(this.x + this.w / 2, this.y + this.h, 15, CONFIG.colors.star);
                    playSound('jump_double');
                }
            }

            update() {
                // Physics
                this.vy += CONFIG.gravity;
                this.y += this.vy;

                // Ground Check
                const groundY = canvas.height - CONFIG.floorHeight - this.h;
                if (this.y >= groundY) {
                    if (!this.isGrounded) {
                        // Landed
                        this.scaleX = 1.3;
                        this.scaleY = 0.7;
                        spawnParticles(this.x + this.w / 2, this.y + this.h, 5, CONFIG.colors.floorLine);
                    }
                    this.y = groundY;
                    this.vy = 0;
                    this.isGrounded = true;
                    this.jumpCount = 0;
                    // Snap rotation
                    this.rotation = Math.round(this.rotation / (Math.PI / 2)) * (Math.PI / 2);
                } else {
                    this.rotation += 0.1;
                }

                // Return to normal scale
                this.scaleX += (1 - this.scaleX) * 0.1;
                this.scaleY += (1 - this.scaleY) * 0.1;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
                ctx.scale(this.scaleX, this.scaleY);
                ctx.rotate(this.rotation);

                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = CONFIG.colors.playerGlow;

                // Body
                ctx.fillStyle = CONFIG.colors.player;
                ctx.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);

                // Eye
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                ctx.fillRect(5, -10, 10, 10);

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.w / 2, -this.h / 2, this.w, this.h);

                ctx.restore();
            }
        }

        // --- Systems ---
        const player = new Player();
        let obstacles = [];
        let particles = [];
        let stars = [];
        let buildingLayers = []; // Parallax

        // Parallax Setup
        function initBackground() {
            buildingLayers = [
                { speed: 0.2, color: '#160f2b', buildings: [] }, // Far
                { speed: 0.5, color: '#241a42', buildings: [] }, // Mid
                { speed: 1.0, color: '#322261', buildings: [] }  // Close
            ];

            // Fill initial buildings
            buildingLayers.forEach(layer => {
                let x = 0;
                while (x < canvas.width + 200) {
                    const w = 50 + Math.random() * 100;
                    const h = 50 + Math.random() * 300;
                    layer.buildings.push({ x, w, h });
                    x += w + Math.random() * 20;
                }
            });
        }

        function updateBackground() {
            buildingLayers.forEach(layer => {
                // Update X
                layer.buildings.forEach(b => {
                    b.x -= state.speed * layer.speed;
                });

                // Wrap / Recycle
                if (layer.buildings[0].x + layer.buildings[0].w < -100) {
                    const first = layer.buildings.shift();
                    const last = layer.buildings[layer.buildings.length - 1];
                    first.x = last.x + last.w + Math.random() * 20;
                    first.h = 50 + Math.random() * 300; // Reshuffle height
                    layer.buildings.push(first);
                }
            });
        }

        function drawBackground() {
            buildingLayers.forEach(layer => {
                ctx.fillStyle = layer.color;
                layer.buildings.forEach(b => {
                    // Draw skyscraper with some "windows"
                    const floorY = canvas.height - CONFIG.floorHeight;
                    ctx.fillRect(b.x, floorY - b.h, b.w, b.h);

                    // Windows (Simple optimization: just dots)
                    // (Skipped for performance if needed, but adding simple glow)
                });
            });
        }

        // --- Main Loop ---
        function loop() {
            if (!state.isPlaying) return;

            // Update
            player.update();
            updateObstacles();
            updateStars();
            updateParticles();
            updateBackground();

            // Screen Shake Decay
            if (state.cameraShake > 0) {
                state.cameraShake *= 0.9;
                if (state.cameraShake < 0.5) state.cameraShake = 0;
            }

            // Progression
            state.distance += state.speed;
            state.speed = CONFIG.initialSpeed + (state.score / 2000); // Speed up slowly
            if (state.speed > CONFIG.maxSpeed) state.speed = CONFIG.maxSpeed;

            state.score += 1;
            document.getElementById('score').innerText = Math.floor(state.score);

            // Draw
            ctx.fillStyle = CONFIG.colors.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply Shake
            ctx.save();
            if (state.cameraShake > 0) {
                const dx = (Math.random() - 0.5) * state.cameraShake;
                const dy = (Math.random() - 0.5) * state.cameraShake;
                ctx.translate(dx, dy);
            }

            drawBackground();

            // Floor
            ctx.shadowBlur = 20;
            ctx.shadowColor = CONFIG.colors.floorLine;
            ctx.fillStyle = CONFIG.colors.floor;
            ctx.fillRect(0, canvas.height - CONFIG.floorHeight, canvas.width, CONFIG.floorHeight);

            // Neon Line
            ctx.fillStyle = CONFIG.colors.floorLine;
            ctx.fillRect(0, canvas.height - CONFIG.floorHeight, canvas.width, 4);
            ctx.shadowBlur = 0; // Reset

            player.draw(ctx);

            obstacles.forEach(drawObstacle);
            stars.forEach(s => s.draw(ctx));
            particles.forEach(p => p.draw(ctx));

            ctx.restore();

            state.frame++;
            requestAnimationFrame(loop);
        }

        function updateObstacles() {
            // Spawning Logic
            if (state.frame % Math.floor(1000 / state.speed) === 0) { // Spawn frequency increases with speed
                spawnObstacle();
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.x -= state.speed;

                // Collision
                if (checkCollision(player, obs)) {
                    gameOver();
                }

                if (obs.x + obs.w < -100) obstacles.splice(i, 1);
            }
        }

        function updateStars() {
            for (let i = stars.length - 1; i >= 0; i--) {
                const star = stars[i];
                star.update();

                // Collect
                const dx = (player.x + player.w / 2) - star.x;
                const dy = (player.y + player.h / 2) - star.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 40) { // Collection radius
                    state.score += 500;
                    spawnParticles(star.x, star.y, 10, star.color);
                    playSound('coin');
                    stars.splice(i, 1);
                } else if (star.x < -100) {
                    stars.splice(i, 1);
                }
            }
        }

        function spawnObstacle() {
            const type = Math.random();
            const floorY = canvas.height - CONFIG.floorHeight;

            if (type > 0.7) {
                // Tall Spike
                obstacles.push({ x: canvas.width, y: floorY - 90, w: 30, h: 90, type: 'tall' });
                // Chance to spawn star above
                stars.push(new Star(canvas.width, floorY - 150));
            } else if (type > 0.4) {
                // Double Mini
                obstacles.push({ x: canvas.width, y: floorY - 40, w: 40, h: 40, type: 'spike' });
                obstacles.push({ x: canvas.width + 45, y: floorY - 40, w: 40, h: 40, type: 'spike' });
            } else {
                // Single
                obstacles.push({ x: canvas.width, y: floorY - 40, w: 40, h: 40, type: 'spike' });
                // Star on ground? unlikely, maybe jump arch
            }
        }

        function drawObstacle(obs) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = CONFIG.colors.obstacle;
            ctx.fillStyle = CONFIG.colors.obstacle;

            // Draw Triangle
            ctx.beginPath();
            ctx.moveTo(obs.x, obs.y + obs.h);
            ctx.lineTo(obs.x + obs.w / 2, obs.y);
            ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        function checkCollision(p, obs) {
            // Hitbox tuning (forgiving)
            const buffering = 10;
            return (
                p.x + buffering < obs.x + obs.w &&
                p.x + p.w - buffering > obs.x &&
                p.y + p.h - buffering > obs.y
            );
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function spawnParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, 5, Math.random() * 5 + 3, 1));
            }
        }

        // --- Game Flow ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (!state.isPlaying) {
                // If waiting, draw title bg maybe?
                ctx.fillStyle = CONFIG.colors.bg;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        window.addEventListener('resize', resize);

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');

            state.isPlaying = true;
            state.score = 0;
            state.speed = CONFIG.initialSpeed;
            obstacles = [];
            particles = [];
            stars = [];

            initBackground();
            player.reset();
            resize();
            loop();
        }

        function resetGame() {
            document.getElementById('game-over-screen').classList.add('hidden');
            startGame();
        }

        function gameOver() {
            state.isPlaying = false;
            state.cameraShake = 20; // Big shake
            playSound('hit');
            document.getElementById('final-score').innerText = Math.floor(state.score);
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('ui-layer').classList.add('hidden');
        }

        // Input
        function handleInput(e) {
            if ((e.code === 'Space' || e.code === 'ArrowUp') || e.type === 'touchstart') {
                if (state.isPlaying) player.jump();
            }
        }
        window.addEventListener('keydown', handleInput);
        window.addEventListener('touchstart', handleInput);

        // Audio
        function playSound(type) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            const ctx = new AudioContext();
            const osc = ctx.createOscillator();
            const g = ctx.createGain();
            osc.connect(g);
            g.connect(ctx.destination);

            const now = ctx.currentTime;

            if (type === 'jump') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(300, now + 0.1);
                g.gain.setValueAtTime(0.1, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start();
                osc.stop(now + 0.1);
            } else if (type === 'jump_double') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.2);
                g.gain.setValueAtTime(0.1, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start();
                osc.stop(now + 0.2);
            } else if (type === 'coin') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.setValueAtTime(1800, now + 0.1);
                g.gain.setValueAtTime(0.1, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start();
                osc.stop(now + 0.1);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
                g.gain.setValueAtTime(0.3, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.start();
                osc.stop(now + 0.5);
            }
        }

        resize();
    </script>
</body>

</html>