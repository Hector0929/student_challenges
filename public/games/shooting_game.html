<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Math Shooter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #0f0b1e;
            color: white;
            overflow: hidden;
            touch-action: none;
        }

        .neon-text {
            text-shadow: 0 0 10px #a855f7, 0 0 20px #a855f7;
        }

        .neon-box {
            background: rgba(15, 23, 42, 0.9);
            border: 2px solid #a855f7;
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.3), inset 0 0 10px rgba(168, 85, 247, 0.1);
        }

        .clay-btn {
            background: linear-gradient(145deg, #1e1b4b, #312e81);
            border: 1px solid #6366f1;
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.4);
            transition: all 0.2s;
        }

        .clay-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 0 25px rgba(99, 102, 241, 0.7);
            border-color: #818cf8;
        }

        .clay-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .clay-btn:disabled {
            background: #1f2937;
            border-color: #374151;
            color: #6b7280;
            box-shadow: none;
            cursor: not-allowed;
        }

        canvas {
            image-rendering: pixelated;
        }

        .hearts-container {
            letter-spacing: 2px;
        }
    </style>
</head>

<body class="bg-[#0f0b1e] text-white overflow-hidden touch-action-none h-screen w-screen flex flex-col">

    <!-- Top Stats Bar -->
    <div class="flex-none p-2 z-20">
        <div class="max-w-4xl mx-auto flex justify-between items-center">
            <div class="neon-box rounded-xl px-4 py-2 flex gap-4 bg-[#0f0b1e]/80 backdrop-blur">
                <span class="text-purple-400 font-bold text-sm md:text-base">SCORE</span>
                <span id="scoreDisplay" class="text-lg md:text-xl text-white">0</span>
            </div>
            <div class="neon-box rounded-xl px-4 py-2 flex gap-1 md:gap-2 bg-[#0f0b1e]/80 backdrop-blur">
                <span class="text-red-500 font-bold text-sm md:text-base">LIVES</span>
                <span id="livesDisplay" class="text-sm md:text-xl text-white tracking-widest">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
            </div>
        </div>
    </div>

    <!-- Game Area (Flexible) -->
    <div id="game-wrapper"
        class="flex-1 relative w-full max-w-4xl mx-auto my-2 border-x-2 border-purple-500/30 overflow-hidden">
        <canvas id="gameCanvas" class="block h-full w-full"></canvas>

        <!-- Question Overlay (Floating Top Center) -->
        <div class="absolute left-0 right-0 top-4 z-10 text-center pointer-events-none">
            <div id="questionDisplay"
                class="neon-text drop-shadow-xl inline-block bg-gradient-to-r from-purple-400 to-cyan-400 bg-clip-text text-5xl font-bold text-transparent md:text-6xl">
                READY?
            </div>
            <!-- Timer Bar -->
            <div class="mx-auto mt-2 h-2 w-64 overflow-hidden rounded-full bg-gray-800/50 backdrop-blur-sm">
                <div id="questionTimerBar"
                    class="h-full bg-cyan-500 shadow-[0_0_10px_#22d3ee] transition-all duration-100 ease-linear"
                    style="width: 100%;"></div>
            </div>
            <!-- Feedback -->
            <div id="feedbackDisplay" class="mt-2 h-8 text-xl font-bold text-shadow-md"></div>
        </div>
    </div>

    <!-- Bottom Controls (Fixed Height) -->
    <div class="flex-none p-4 pb-8 z-20 bg-gradient-to-t from-[#0f0b1e] to-transparent">
        <div class="mx-auto max-w-2xl">
            <!-- Answers Grid -->
            <div id="answerOptionsContainer" class="mb-4 grid grid-cols-2 gap-4">
                <!-- Buttons injected by JS -->
            </div>

            <!-- Start / Controls -->
            <div class="flex justify-center gap-4">
                <button id="startGameButton"
                    class="clay-btn shadow-2xl w-full max-w-xs rounded-xl px-8 py-3 text-xl font-bold text-white">
                    START MISSION
                </button>
                <button id="specialCannonButton"
                    class="clay-btn animate-pulse hidden whitespace-nowrap rounded-xl border-yellow-500 px-6 py-3 text-lg font-bold text-yellow-300 shadow-[0_0_15px_rgba(234,179,8,0.4)]">
                    ‚ö° SUPER BEAM
                </button>
            </div>
        </div>
    </div>

    <!-- Celebration Overlay -->
    <div id="celebrationScreen"
        class="absolute inset-0 z-50 hidden flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div class="neon-box animate-[bounce_1s_infinite] mx-4 max-w-sm rounded-2xl p-8 text-center">
            <div class="mb-4 text-6xl">üéâ</div>
            <h2 class="neon-text mb-2 text-3xl font-bold text-purple-400">MISSION COMPLETE!</h2>
            <p class="mb-2 text-gray-300">FINAL SCORE</p>
            <p id="finalScore" class="mb-8 text-5xl font-bold text-white text-shadow-lg">0</p>
            <button id="restartGameButton" class="clay-btn w-full rounded-xl px-8 py-3 text-xl font-bold text-white">
                PLAY AGAIN
            </button>
        </div>
    </div>

    <script>
        /**
         * NEON MATH SHOOTER - Responsive Fit
         */
        const canvas = document.getElementById('gameCanvas');
        const wrapper = document.getElementById('game-wrapper');
        const ctx = canvas.getContext('2d');

        // Game Configuration
        const CONFIG = {
            width: 800,
            height: 600, // Will be updated by resize
            colors: {
                bg: '#0f0b1e',
                player: '#22d3ee',
                playerGlow: '#06b6d4',
                enemy: '#f472b6',
                enemyGlow: '#db2777',
                bullet: '#facc15',
                bulletGlow: '#eab308'
            }
        };

        // Game State
        let state = {
            isPlaying: false,
            score: 0,
            lives: 12,
            questionTime: 5,
            lastFrame: 0,
            specialReady: false,
            lastSpecialScore: 0,
            shake: 0
        };

        // Entities
        let player, enemies = [], bullets = [], particles = [], stars = [];
        // Logic
        let currentQuestion = null;
        let gameLoopId, questionTimerId;
        let enemySpawnTimer = 0;

        // Resize handling
        function resize() {
            const rect = wrapper.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            CONFIG.width = rect.width;
            CONFIG.height = rect.height;

            // Reposition player if exists
            if (player) {
                player.x = CONFIG.width / 2;
                player.y = CONFIG.height - 80;
                player.targetX = player.x;
            }
        }
        window.addEventListener('resize', resize);
        // Call resize immediately and after short delay to ensure layout is settled
        resize();
        setTimeout(resize, 100);

        // UI References
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const questionDisplay = document.getElementById('questionDisplay');
        const answerOptionsContainer = document.getElementById('answerOptionsContainer');
        const questionTimerBar = document.getElementById('questionTimerBar');
        const feedbackDisplay = document.getElementById('feedbackDisplay');
        const startGameButton = document.getElementById('startGameButton');
        const specialCannonButton = document.getElementById('specialCannonButton');
        const celebrationScreen = document.getElementById('celebrationScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartGameButton = document.getElementById('restartGameButton');

        // Game State
        let state = {
            isPlaying: false,
            score: 0,
            lives: 12,
            questionTime: 5,
            lastFrame: 0,
            specialReady: false,
            lastSpecialScore: 0,
            shake: 0
        };

        // Entities
        let player, enemies = [], bullets = [], particles = [], stars = [];
        // Logic
        let currentQuestion = null;
        let gameLoopId, questionTimerId;
        let enemySpawnTimer = 0;

        // --- Classes ---

        class Star {
            constructor() {
                this.x = Math.random() * CONFIG.width;
                this.y = Math.random() * CONFIG.height;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 0.5 + 0.1;
                this.brightness = Math.random();
            }
            update() {
                this.y += this.speed;
                if (this.y > CONFIG.height) {
                    this.y = 0;
                    this.x = Math.random() * CONFIG.width;
                }
                this.brightness = 0.5 + Math.sin(Date.now() * 0.005 + this.x) * 0.5;
            }
            draw(ctx) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Player {
            constructor() {
                this.w = 50;
                this.h = 50;
                this.x = CONFIG.width / 2;
                this.y = CONFIG.height - 70;
                this.targetX = this.x;
            }

            update() {
                // Smooth movement to target
                this.x += (this.targetX - this.x) * 0.1;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = CONFIG.colors.playerGlow;
                ctx.strokeStyle = CONFIG.colors.player;
                ctx.fillStyle = '#000';
                ctx.lineWidth = 2;

                // Ship Shape
                ctx.beginPath();
                ctx.moveTo(0, -25);
                ctx.lineTo(20, 25);
                ctx.lineTo(0, 15); // Engine indent
                ctx.lineTo(-20, 25);
                ctx.closePath();

                ctx.fill();
                ctx.stroke();

                // Detailed Engine Glow
                ctx.shadowBlur = 10;
                ctx.fillStyle = CONFIG.colors.player;
                ctx.beginPath();
                ctx.arc(0, 15, 3 + Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.w = 40;
                this.h = 40;
                this.speed = 1.5;
                this.rotation = 0;
            }

            update() {
                this.y += this.speed;
                this.rotation += 0.05;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
                ctx.rotate(this.rotation);

                ctx.shadowBlur = 15;
                ctx.shadowColor = CONFIG.colors.enemyGlow;
                ctx.strokeStyle = CONFIG.colors.enemy;
                ctx.lineWidth = 2;

                // Geometric Shape (Diamond)
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(20, 0);
                ctx.lineTo(0, 20);
                ctx.lineTo(-20, 0);
                ctx.closePath();
                ctx.stroke();

                // Inner core
                ctx.fillStyle = CONFIG.colors.enemy;
                ctx.globalAlpha = 0.3;
                ctx.fill();
                ctx.globalAlpha = 1;

                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, target) {
                this.x = x;
                this.y = y;
                this.w = 6;
                this.h = 20;
                this.speed = 12;
                this.target = target;

                if (target) {
                    // Homing logic (simple)
                    const dx = (target.x + target.w / 2) - x;
                    const dy = (target.y + target.h / 2) - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    this.vx = (dx / dist) * this.speed;
                    this.vy = (dy / dist) * this.speed;
                    this.angle = Math.atan2(this.vy, this.vx) + Math.PI / 2;
                } else {
                    this.vx = 0;
                    this.vy = -this.speed;
                    this.angle = 0;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                ctx.shadowBlur = 10;
                ctx.shadowColor = CONFIG.colors.bulletGlow;
                ctx.fillStyle = CONFIG.colors.bullet;

                // Laser beam shape
                ctx.beginPath();
                ctx.roundRect(-3, -10, 6, 20, 3);
                ctx.fill();

                ctx.restore();
            }
        }

        // --- Core Systems ---

        function init() {
            try {
                player = new Player();
                stars = Array(50).fill().map(() => new Star());

                // Auto-start game on load for better UX
                startGame();

                // Initial render
                loop(0);
            } catch (e) {
                console.error("Game Init Error:", e);
            }
        }

        function loop(timestamp) {
            if (!state.lastFrame) state.lastFrame = timestamp;
            const dt = (timestamp - state.lastFrame) / 16.67;
            state.lastFrame = timestamp;

            // Clear
            ctx.fillStyle = CONFIG.colors.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Screen Shake
            ctx.save();
            if (state.shake > 0) {
                const dx = (Math.random() - 0.5) * state.shake;
                const dy = (Math.random() - 0.5) * state.shake;
                ctx.translate(dx, dy);
                state.shake *= 0.9;
                if (state.shake < 0.5) state.shake = 0;
            }

            // Update & Draw Background
            stars.forEach(s => { s.update(); s.draw(ctx); });

            // Player
            if (player) {
                player.update();
                player.draw(ctx);
            }

            if (state.isPlaying) {
                // Spawning - check count
                enemySpawnTimer++;
                // Spawn faster: every 40 frames instead of 60
                if (enemySpawnTimer > 40) {
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }

                // Entities Update & Draw
                updateEntities();
                checkCollisions();
            }

            // Always draw entities (even particles if game over)
            bullets.forEach(b => b.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            particles.forEach(p => { p.update(); p.draw(ctx); });

            ctx.restore(); // Restore shake

            requestAnimationFrame(loop);
        }

        function updateEntities() {
            // Cleanup off-screen
            bullets = bullets.filter(b => b.y > -50 && b.y < CONFIG.height + 50 && b.x > -50 && b.x < CONFIG.width + 50);

            // Special: Check if enemies hit bottom
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.update();

                if (e.y > CONFIG.height + 50) {
                    // Enemy breached! Damage!
                    enemies.splice(i, 1);
                    takeDamage();
                }
            }

            particles = particles.filter(p => p.life > 0);
            bullets.forEach(b => b.update());
        }

        function spawnEnemy() {
            if (enemies.length >= 10) return;
            const x = Math.random() * (CONFIG.width - 60) + 10;
            enemies.push(new Enemy(x, -50));
        }

        function spawnParticles(x, y, count = 10, color = '#fff') {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function takeDamage() {
            if (!state.isPlaying) return;
            state.lives--;
            updateLivesDisplay();
            state.shake = 10; // Trigger shake

            // Feedback
            feedbackDisplay.innerText = "WARNING! BREACH!";
            feedbackDisplay.className = "h-6 text-sm font-bold mb-1 text-red-500 animate-pulse";

            if (state.lives <= 0) {
                endGame(false);
            }
        }

        function updateLivesDisplay() {
            let hearts = "";
            for (let i = 0; i < state.lives; i++) hearts += "‚ù§Ô∏è";
            livesDisplay.innerText = hearts;
        }

        function checkCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const b = bullets[i];
                    const e = enemies[j];

                    if (!b || !e) continue;

                    // Simple AABB / Hitbox
                    if (b.x > e.x && b.x < e.x + e.w &&
                        b.y > e.y && b.y < e.y + e.h) {

                        // Hit!
                        spawnParticles(e.x + e.w / 2, e.y + e.h / 2, 10, CONFIG.colors.enemy);
                        enemies.splice(j, 1);
                        bullets.splice(i, 1);

                        addScore(10);
                        break;
                    }
                }
            }
        }

        // --- Math Logic ---

        let askedQuestions = new Set();

        function generateQuestion() {
            let num1, num2, qStr;
            do {
                num1 = Math.floor(Math.random() * 9) + 1;
                num2 = Math.floor(Math.random() * 9) + 1;
                qStr = `${Math.min(num1, num2)}x${Math.max(num1, num2)}`;
            } while (askedQuestions.has(qStr) && askedQuestions.size < 50);

            if (askedQuestions.size >= 50) askedQuestions.clear();
            askedQuestions.add(qStr);

            currentQuestion = { num1, num2, ans: num1 * num2 };

            // Visual Update
            questionDisplay.innerText = `${num1} √ó ${num2} = ?`;
            questionDisplay.classList.remove('text-red-500');
            questionDisplay.classList.add('text-transparent'); // Restore gradient

            resetTimerBar();
            generateAnswers(currentQuestion.ans);
        }

        function generateAnswers(correct) {
            const answers = [correct];
            while (answers.length < 4) {
                let wrong = Math.floor(Math.random() * 81) + 1;
                if (!answers.includes(wrong) && Math.abs(wrong - correct) > 2) {
                    answers.push(wrong);
                }
            }
            // Shuffle
            answers.sort(() => Math.random() - 0.5);

            answerOptionsContainer.innerHTML = '';
            answers.forEach(ans => {
                const btn = document.createElement('button');
                btn.textContent = ans;
                btn.className = 'clay-btn text-white text-3xl font-bold py-4 rounded-xl shadow-lg active:scale-95 transition-transform';
                btn.onclick = () => handleAnswer(ans);
                answerOptionsContainer.appendChild(btn);
            });
        }

        function handleAnswer(val) {
            if (!state.isPlaying) return;

            if (val === currentQuestion.ans) {
                // Correct!
                feedbackDisplay.innerText = "EXCELLENT!";
                feedbackDisplay.className = "h-6 text-sm font-bold mb-1 text-green-400";
                addScore(50);

                // Fire Bullets!
                const burst = 5;
                fireBullets(burst);

                generateQuestion();
            } else {
                // Wrong
                feedbackDisplay.innerText = "TRY AGAIN!";
                feedbackDisplay.className = "h-6 text-sm font-bold mb-1 text-red-500 animate-pulse";
            }
        }

        function fireBullets(count) {
            // Sort enemies by proximity (lowest Y)
            let targets = [...enemies].sort((a, b) => b.y - a.y); // Bottom first

            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    // Check if target still exists
                    let freshTargets = [...enemies].sort((a, b) => b.y - a.y);
                    const target = freshTargets[i % freshTargets.length]; // cycle targets if not enough

                    const bX = player.x;
                    const bY = player.y - 20;
                    bullets.push(new Bullet(bX, bY, target));
                }, i * 100);
            }
        }

        function fireSpecial() {
            if (!state.specialReady) return;

            // BEAM
            feedbackDisplay.innerText = "SUPER BEAM ACTIVATED!";
            feedbackDisplay.className = "h-6 text-sm font-bold mb-1 text-yellow-300";

            // Fan of bullets
            for (let i = -2; i <= 2; i++) {
                const b = new Bullet(player.x, player.y - 20, null);
                b.vx = i * 2;
                b.w = 50; // Huge beam
                b.h = 100;
                b.speed = 20;
                bullets.push(b);
            }
            // Clear all enemies logic visually
            enemies.forEach(e => spawnParticles(e.x, e.y, 15, CONFIG.colors.enemy));
            const killCount = enemies.length;
            enemies = [];
            addScore(killCount * 20);

            // Reset
            state.specialReady = false;
            specialCannonButton.classList.add('hidden');
        }

        // --- Game Flow ---

        function startGame() {
            console.log("Game Started");
            state.isPlaying = true;
            state.score = 0;
            state.lives = 12;
            state.specialReady = false;
            state.lastSpecialScore = 0;

            scoreDisplay.innerText = 0;
            updateLivesDisplay();

            enemies = [];
            bullets = [];

            startGameButton.classList.add('hidden');
            celebrationScreen.classList.add('hidden');

            generateQuestion();
        }

        function endGame(timeUp) {
            state.isPlaying = false;
            clearInterval(questionTimerId);

            // Show Final Screen
            celebrationScreen.classList.remove('hidden');
            document.querySelector('#celebrationScreen h2').innerText = "GAME OVER";
            finalScoreDisplay.innerText = state.score;
        }

        function addScore(n) {
            state.score += n;
            scoreDisplay.innerText = state.score;

            // Check Special
            if (state.score - state.lastSpecialScore >= 200) {
                state.specialReady = true;
                state.lastSpecialScore = state.score;
                specialCannonButton.classList.remove('hidden');
            }
        }

        function resetTimerBar() {
            if (questionTimerId) clearInterval(questionTimerId);
            state.questionTime = 5;
            questionTimerBar.style.width = '100%';

            questionTimerId = setInterval(() => {
                state.questionTime -= 0.1;
                const pct = (state.questionTime / 5) * 100;
                questionTimerBar.style.width = pct + '%';

                if (pct < 30) questionTimerBar.className = "h-full bg-red-500 shadow-[0_0_10px_#ef4444] transition-all duration-100 ease-linear";
                else questionTimerBar.className = "h-full bg-cyan-500 shadow-[0_0_10px_#22d3ee] transition-all duration-100 ease-linear";

                if (state.questionTime <= 0) {
                    clearInterval(questionTimerId);
                    // Time out on question = Refresh
                    feedbackDisplay.innerText = "TOO SLOW!";
                    feedbackDisplay.className = "h-6 text-sm font-bold mb-1 text-red-500";
                    generateQuestion();
                }
            }, 100);
        }

        // --- Inputs ---

        startGameButton.onclick = startGame;
        restartGameButton.onclick = startGame;
        specialCannonButton.onclick = fireSpecial;

        // Init
        init();

    </script>
</body>

</html>