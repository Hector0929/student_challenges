<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Snake</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #050510;
            overflow-x: hidden;
            overflow-y: auto;
            touch-action: manipulation;
            min-height: 100vh;
            min-height: 100dvh;
            /* Prevent zoom/scroll */
        }

        .neon-text {
            text-shadow: 0 0 10px #22d3ee, 0 0 20px #22d3ee;
        }

        .neon-border {
            box-shadow: 0 0 10px #22d3ee, inset 0 0 10px #22d3ee;
            border: 2px solid #22d3ee;
        }

        .glass-panel {
            background: rgba(10, 10, 30, 0.8);
            backdrop-filter: blur(8px);
        }

        canvas {
            image-rendering: pixelated;
        }

        /* Mobile Controls - ÊîæÂ§ßÁâà */
        .d-pad-btn {
            background: rgba(34, 211, 238, 0.15);
            border: 2px solid rgba(34, 211, 238, 0.4);
            border-radius: 12px;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: #22d3ee;
            transition: all 0.1s;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .d-pad-btn:active {
            background: rgba(34, 211, 238, 0.5);
            transform: scale(0.95);
            box-shadow: 0 0 20px rgba(34, 211, 238, 0.5);
        }
    </style>
</head>

<body class="min-h-screen h-[100dvh] flex flex-col items-center justify-start py-3 sm:py-5 px-2">

    <!-- UI Overlay -->
    <div id="ui-layer"
        class="pointer-events-none w-full max-w-lg mx-auto mb-1 sm:mb-2 z-10">
        <!-- Header -->
        <div class="grid grid-cols-2 sm:grid-cols-4 gap-1.5 items-start">
            <div class="glass-panel rounded-xl px-3 py-1.5 border border-cyan-500/50">
                <div class="text-cyan-400 text-[10px] sm:text-xs">SCORE</div>
                <div id="score" class="text-xl sm:text-2xl text-white font-bold">0</div>
            </div>
            <div class="glass-panel rounded-xl px-3 py-1.5 border border-cyan-500/50">
                <div class="text-cyan-400 text-[10px] sm:text-xs">HIGH</div>
                <div id="high-score" class="text-xl sm:text-2xl text-white font-bold">0</div>
            </div>
            <div class="glass-panel rounded-xl px-3 py-1.5 border border-cyan-500/50">
                <div class="text-cyan-400 text-[10px] sm:text-xs">COMBO</div>
                <div id="combo" class="text-xl sm:text-2xl text-white font-bold">0</div>
            </div>
            <div class="glass-panel rounded-xl px-3 py-1.5 border border-cyan-500/50">
                <div class="text-cyan-400 text-[10px] sm:text-xs">MISSION</div>
                <div id="mission" class="text-[10px] sm:text-[11px] leading-4 text-white font-bold">Ê∫ñÂÇô‰∏≠...</div>
            </div>
        </div>
        <div id="phase" class="text-center text-cyan-200 text-xs sm:text-sm font-bold mt-1">ÈñãÂßã 10 ÁßíÈ©öÂñú</div>
    </div>

    <!-- Start / Game Over Screen -->
    <div id="menu-screen" class="absolute inset-0 z-20 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div
            class="glass-panel rounded-2xl p-8 text-center max-w-sm mx-4 border border-cyan-500 shadow-2xl shadow-cyan-500/20">
            <div class="text-6xl mb-4 animate-pulse">üêç</div>
            <h1
                class="text-4xl text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600 font-bold mb-2 neon-text">
                NEON SNAKE
            </h1>
            <p id="menu-message" class="text-cyan-200/70 mb-8 tracking-wider">CYBERPUNK EATER</p>

            <button onclick="startGame()"
                class="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 px-8 rounded-xl transition-all transform hover:scale-105 shadow-lg shadow-cyan-500/50">
                START GAME
            </button>
        </div>
    </div>

    <!-- Game Canvas -->
    <div
        class="relative w-full max-w-lg aspect-square max-h-[calc(100dvh-10.25rem)] sm:max-h-[calc(100dvh-9rem)] neon-border rounded-lg bg-black/50 overflow-hidden shadow-2xl shadow-cyan-900/50">
        <canvas id="gameCanvas" class="w-full h-full block"></canvas>
    </div>

    <!-- Mobile Controls (Visible only on touch devices) -->
    <div id="mobile-controls"
        class="hidden absolute bottom-8 w-full max-w-md justify-center gap-4 z-20 pointer-events-auto">
        <div class="grid grid-cols-3 gap-2">
            <div></div> <!-- Empty -->
            <button class="d-pad-btn" ontouchstart="handleInput('ArrowUp', event)">‚ñ≤</button>
            <div></div> <!-- Empty -->

            <button class="d-pad-btn" ontouchstart="handleInput('ArrowLeft', event)">‚óÄ</button>
            <button class="d-pad-btn" ontouchstart="handleInput('ArrowDown', event)">‚ñº</button>
            <button class="d-pad-btn" ontouchstart="handleInput('ArrowRight', event)">‚ñ∂</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('high-score');
        const comboDisplay = document.getElementById('combo');
        const missionDisplay = document.getElementById('mission');
        const phaseDisplay = document.getElementById('phase');
        const menuScreen = document.getElementById('menu-screen');
        const mobileControls = document.getElementById('mobile-controls');

        // Config - ÊîæÂ§ßÈÅäÊà≤Áï´Èù¢
        const GRID_SIZE = 20;
        let TILE_COUNT = 15; // Ê∏õÂ∞ëÊ†ºÊï∏ = ÊîæÂ§ßÊØèÊ†ºÂ∞∫ÂØ∏
        const GAME_SPEED_START = 150;

        let state = {
            isPlaying: false,
            score: 0,
            highScore: localStorage.getItem('snake_highscore') || 0,
            snake: [],
            vel: { x: 0, y: 0 },
            food: { x: 15, y: 15 },
            nextVel: { x: 0, y: 0 }, // Buffered input prevent self-collision
            speed: GAME_SPEED_START,
            lastTime: 0,
            accumulatedTime: 0,
            combo: 0,
            maxCombo: 0,
            foodsEaten: 0,
            mission: null,
            gameStartAt: 0
        };

        function createMission() {
            const missions = [
                { id: 'foods', title: 'ÂêÉÂà∞ 8 È°ÜÊûúÂØ¶', target: 8, progress: 0, reward: 40 },
                { id: 'edge', title: 'ÈÇäÈÇäÂêÉÊûúÂØ¶ 4 Ê¨°', target: 4, progress: 0, reward: 60 }
            ];
            return { ...missions[Math.floor(Math.random() * missions.length)], done: false };
        }

        function updateComboUI() {
            comboDisplay.innerText = state.combo;
        }

        function updateMissionUI() {
            if (!state.mission) return;
            missionDisplay.innerText = `${state.mission.title} (${Math.min(state.mission.progress, state.mission.target)}/${state.mission.target})`;
        }

        function updatePhaseLabel() {
            if (!state.isPlaying) return;
            const elapsed = (performance.now() - state.gameStartAt) / 1000;
            if (elapsed <= 10) {
                phaseDisplay.innerText = 'ÈñãÂßã 10 ÁßíÈ©öÂñú';
            } else if (elapsed <= 40) {
                phaseDisplay.innerText = '30 Áßí‰ªªÂãôÊöñË∫´';
            } else if (elapsed <= 160) {
                phaseDisplay.innerText = '120 ÁßíÁ≤æÂΩ©ÊôÇÂàª';
            } else {
                phaseDisplay.innerText = 'ÁµêÊùüÁçéÂãµ';
            }
        }

        function markMission(type, amount = 1) {
            if (!state.mission || state.mission.done || state.mission.id !== type) return;
            state.mission.progress += amount;
            updateMissionUI();
            if (state.mission.progress >= state.mission.target) {
                state.mission.done = true;
                state.score += state.mission.reward;
                scoreDisplay.innerText = state.score;
            }
        }

        // Initialize High Score
        highScoreDisplay.innerText = state.highScore;

        // Resize Logic
        function resize() {
            // Make canvas square within the container
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // Âõ∫ÂÆö TILE_COUNT = 15 ËÆìÊ†ºÂ≠êÊõ¥Â§ßÊõ¥ÂÆπÊòìÁúã
            TILE_COUNT = 15;

            // Check if mobile
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                mobileControls.classList.remove('hidden');
                mobileControls.classList.add('flex');
            }

            if (!state.isPlaying) draw();
        }
        window.addEventListener('resize', resize);
        resize();

        function startGame() {
            menuScreen.classList.add('hidden');
            state.score = 0;
            state.speed = GAME_SPEED_START;
            state.combo = 0;
            state.maxCombo = 0;
            state.foodsEaten = 0;
            state.mission = createMission();
            state.gameStartAt = performance.now();
            scoreDisplay.innerText = 0;
            updateComboUI();
            updateMissionUI();
            phaseDisplay.innerText = 'ÈñãÂßã 10 ÁßíÈ©öÂñú';

            // Reset Snake
            state.snake = [
                { x: 10, y: 10 },
                { x: 10, y: 11 },
                { x: 10, y: 12 }
            ];
            state.vel = { x: 0, y: -1 }; // Start moving up
            state.nextVel = { x: 0, y: -1 };

            spawnFood();

            state.isPlaying = true;
            state.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            state.isPlaying = false;
            menuScreen.classList.remove('hidden');

            // Update High Score
            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('snake_highscore', state.highScore);
                highScoreDisplay.innerText = state.highScore;
            }

            const missionText = state.mission?.done ? '‰ªªÂãôÂÆåÊàê ‚úÖ' : '‰ªªÂãô‰∏ãÊ¨°ÂÜçÊåëÊà∞ üí™';
            document.getElementById('menu-message').innerText = `ÂàÜÊï∏ ${state.score}ÔΩúÊúÄÈ´òÈÄ£Êìä ${state.maxCombo}ÔΩú${missionText}`;
            document.querySelector('#menu-screen h1').innerText = "CRASHED";
        }

        function spawnFood() {
            let valid = false;
            while (!valid) {
                state.food = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT)
                };
                // Check if food spawns on snake
                valid = !state.snake.some(segment => segment.x === state.food.x && segment.y === state.food.y);
            }
        }

        function handleInput(key, e) {
            if (e) e.preventDefault(); // Prevent scroll on mobile
            if (!state.isPlaying && (key === 'Enter' || key === ' ')) {
                startGame();
                return;
            }

            // Prevent reversing direction directly
            switch (key) {
                case 'ArrowUp':
                    if (state.vel.y !== 1) state.nextVel = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    if (state.vel.y !== -1) state.nextVel = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    if (state.vel.x !== 1) state.nextVel = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    if (state.vel.x !== -1) state.nextVel = { x: 1, y: 0 };
                    break;
            }
        }

        document.addEventListener('keydown', e => handleInput(e.key));

        // Touch Swipe Support
        let touchStart = { x: 0, y: 0 };
        document.addEventListener('touchstart', e => {
            touchStart.x = e.touches[0].clientX;
            touchStart.y = e.touches[0].clientY;
        }, { passive: false });

        document.addEventListener('touchend', e => {
            if (!state.isPlaying) return;
            const dx = e.changedTouches[0].clientX - touchStart.x;
            const dy = e.changedTouches[0].clientY - touchStart.y;

            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal
                if (Math.abs(dx) > 30) handleInput(dx > 0 ? 'ArrowRight' : 'ArrowLeft');
            } else {
                // Vertical
                if (Math.abs(dy) > 30) handleInput(dy > 0 ? 'ArrowDown' : 'ArrowUp');
            }
        }, { passive: false });

        function update() {
            // Apply next velocity
            state.vel = state.nextVel;

            const head = {
                x: state.snake[0].x + state.vel.x,
                y: state.snake[0].y + state.vel.y
            };

            // Wall Collision
            if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
                gameOver();
                return;
            }

            // Self Collision
            if (state.snake.some(s => s.x === head.x && s.y === head.y)) {
                gameOver();
                return;
            }

            state.snake.unshift(head);

            // Eat Food
            if (head.x === state.food.x && head.y === state.food.y) {
                state.combo += 1;
                state.maxCombo = Math.max(state.maxCombo, state.combo);
                state.foodsEaten += 1;

                const nearWall = head.x <= 1 || head.y <= 1 || head.x >= TILE_COUNT - 2 || head.y >= TILE_COUNT - 2;
                const comboBonus = Math.min(20, state.combo * 2);
                const edgeBonus = nearWall ? 12 : 0;

                state.score += 10 + comboBonus + edgeBonus;
                scoreDisplay.innerText = state.score;
                updateComboUI();

                markMission('foods');
                if (nearWall) {
                    markMission('edge');
                }

                spawnFood();

                // Speed up slightly
                if (state.speed > 50) state.speed -= 2;
            } else {
                state.snake.pop(); // Remove tail
            }
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const tileSize = canvas.width / TILE_COUNT;

            // Draw Grid (Optional, simple)
            ctx.strokeStyle = '#22d3ee11'; // Very faint cyan
            ctx.lineWidth = 1;
            /*
            ctx.beginPath();
            for(let i=0; i<=TILE_COUNT; i++) {
                ctx.moveTo(i*tileSize, 0); ctx.lineTo(i*tileSize, canvas.height);
                ctx.moveTo(0, i*tileSize); ctx.lineTo(canvas.width, i*tileSize);
            }
            ctx.stroke();
            */

            // Draw Food
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#f472b6'; // Pink glow
            ctx.fillStyle = '#f472b6';
            ctx.beginPath();
            ctx.arc(
                state.food.x * tileSize + tileSize / 2,
                state.food.y * tileSize + tileSize / 2,
                tileSize / 3, 0, Math.PI * 2
            );
            ctx.fill();

            // Draw Snake
            state.snake.forEach((seg, index) => {
                const x = seg.x * tileSize;
                const y = seg.y * tileSize;

                ctx.shadowBlur = index === 0 ? 20 : 10;
                ctx.shadowColor = '#22d3ee'; // Cyan glow
                ctx.fillStyle = index === 0 ? '#ccfbf1' : '#22d3ee'; // Head is lighter

                // Rounded Rect for segments
                ctx.fillRect(x + 1, y + 1, tileSize - 2, tileSize - 2);

                // Eyes for head
                if (index === 0) {
                    ctx.fillStyle = '#000';
                    const eyeSize = tileSize / 5;
                    // Simple logic for eyes based on direction could go here
                    ctx.fillRect(x + tileSize / 3, y + tileSize / 3, eyeSize, eyeSize);
                }
            });

            ctx.shadowBlur = 0;
        }

        function gameLoop(time) {
            if (!state.isPlaying) return;

            updatePhaseLabel();

            const dt = time - state.lastTime;
            state.lastTime = time;
            state.accumulatedTime += dt;

            if (state.accumulatedTime > state.speed) {
                update();
                state.accumulatedTime = 0;
                draw();
            }

            requestAnimationFrame(gameLoop);
        }

        // Initial Draw
        draw();

    </script>
</body>

</html>