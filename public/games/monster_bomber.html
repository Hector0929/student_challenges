<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>æ€ªç¸å¡”çˆ†çˆ†å†’éšª</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #121d32;
      --panel-border: #2b3c62;
      --accent: #38bdf8;
      --accent-2: #a78bfa;
      --good: #34d399;
      --warn: #f59e0b;
      --danger: #ef4444;
      --text: #f8fafc;
      --text-dim: #cbd5e1;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;
      background: radial-gradient(circle at top, #111c33 0%, var(--bg) 60%);
      color: var(--text);
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
      min-height: 100dvh;
      display: flex;
      justify-content: center;
      padding: 10px;
    }

    .game-shell {
      width: min(100%, 980px);
      display: grid;
      gap: 10px;
      grid-template-rows: auto auto 1fr auto;
    }

    .title {
      text-align: center;
      font-size: clamp(1.3rem, 2.4vw, 1.8rem);
      font-weight: 800;
      letter-spacing: 0.04em;
      margin: 2px 0 0;
      color: #fde68a;
      text-shadow: 0 2px 12px rgba(245, 158, 11, 0.35);
    }

    .hud {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .hud-item {
      background: rgba(18, 29, 50, 0.9);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 8px;
      text-align: center;
      font-size: 0.9rem;
      line-height: 1.25;
    }

    .hud-item b {
      display: block;
      color: #fef08a;
      font-size: 1rem;
      margin-top: 2px;
    }

    .stage {
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      border: 2px solid var(--panel-border);
      background: #0f172a;
      min-height: 320px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      display: block;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      outline: none;
      touch-action: none;
      background: #0e1b2f;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(2, 8, 23, 0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 8;
      padding: 16px;
    }

    .dialog {
      width: min(92%, 560px);
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      padding: 18px;
      text-align: center;
      box-shadow: 0 18px 38px rgba(2, 8, 23, 0.55);
    }

    .dialog h2 {
      margin: 0 0 8px;
      font-size: clamp(1.35rem, 4.6vw, 2rem);
      color: #fef08a;
    }

    .dialog p {
      margin: 8px 0;
      color: var(--text-dim);
      line-height: 1.5;
      font-size: 0.95rem;
    }

    .cta {
      margin-top: 12px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(120deg, var(--accent), var(--accent-2));
      color: white;
      font-weight: 800;
      font-size: 1rem;
      padding: 10px 18px;
      cursor: pointer;
    }

    .controls {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr auto;
      align-items: center;
      background: rgba(18, 29, 50, 0.9);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 10px;
    }

    .hint {
      font-size: 0.88rem;
      color: var(--text-dim);
      line-height: 1.45;
    }

    .bomb-btn {
      border: none;
      border-radius: 999px;
      width: 76px;
      aspect-ratio: 1;
      background: radial-gradient(circle at 32% 28%, #9ca3af 0%, #1f2937 70%);
      color: white;
      font-size: 1.55rem;
      font-weight: 800;
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.35);
      cursor: pointer;
      touch-action: manipulation;
    }

    @media (max-width: 760px) {
      .hud {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>
<body>
  <main class="game-shell">
    <h1 class="title">æ€ªç¸å¡”çˆ†çˆ†å†’éšªï¼ˆ10 é—œï¼‰</h1>

    <section class="hud">
      <div class="hud-item">é—œå¡<b id="level">1 / 10</b></div>
      <div class="hud-item">åˆ†æ•¸<b id="score">0</b></div>
      <div class="hud-item">ç”Ÿå‘½<b id="lives">â¤ï¸â¤ï¸â¤ï¸</b></div>
      <div class="hud-item">æ€ªç¸å‰©é¤˜<b id="enemyCount">0</b></div>
    </section>

    <section class="stage">
      <canvas id="gameCanvas" tabindex="0"></canvas>
      <div class="overlay" id="overlay">
        <div class="dialog" id="dialog"></div>
      </div>
    </section>

    <section class="controls">
      <div class="hint">
        æ‰‹æ©Ÿï¼šåœ¨åœ°åœ–ä¸Š <b>æ»‘å‹•</b> æ§åˆ¶ä¸Šä¸‹å·¦å³ï¼Œ<b>é€£é»å…©ä¸‹</b> æ”¾ç‚¸å½ˆã€‚<br>
        éµç›¤ï¼š<b>æ–¹å‘éµ</b> ç§»å‹•ï¼Œ<b>ç©ºç™½éµ</b> æ”¾ç‚¸å½ˆã€‚
      </div>
      <button class="bomb-btn" id="bombButton" aria-label="æ”¾ç½®ç‚¸å½ˆ">ğŸ’£</button>
    </section>
  </main>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const overlay = document.getElementById('overlay');
    const dialog = document.getElementById('dialog');

    const levelEl = document.getElementById('level');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const enemyCountEl = document.getElementById('enemyCount');
    const bombBtn = document.getElementById('bombButton');

    const TILE = 0;
    const WALL = 1;
    const BRICK = 2;

    const MAP_COLS = 15;
    const MAP_ROWS = 13;
    const TILE_SIZE = 40;

    canvas.width = MAP_COLS * TILE_SIZE;
    canvas.height = MAP_ROWS * TILE_SIZE;

    const GAME_STATE = {
      START: 'START',
      PLAYING: 'PLAYING',
      LEVEL_CLEAR: 'LEVEL_CLEAR',
      GAME_OVER: 'GAME_OVER',
      GAME_WIN: 'GAME_WIN',
    };

    const ENEMY_THEMES = [
      { primary: '#fb7185', secondary: '#be123c', eye: '#fff1f2' },
      { primary: '#f59e0b', secondary: '#b45309', eye: '#fffbeb' },
      { primary: '#34d399', secondary: '#047857', eye: '#ecfdf5' },
      { primary: '#60a5fa', secondary: '#1d4ed8', eye: '#eff6ff' },
      { primary: '#a78bfa', secondary: '#6d28d9', eye: '#f5f3ff' },
      { primary: '#22d3ee', secondary: '#0e7490', eye: '#ecfeff' },
    ];

    function roundedRectPath(x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    let gameState = GAME_STATE.START;
    let level = 1;
    let score = 0;

    const playerStats = {
      lives: 3,
      speedTier: 1,
      bombCount: 1,
      bombRange: 1,
    };

    let map = [];
    let player = null;
    let enemies = [];
    let bombs = [];
    let explosions = [];
    let items = [];
    let exit = null;

    const input = { up: false, down: false, left: false, right: false, bomb: false };

    function toGrid(px, py) {
      return {
        x: Math.floor((px + TILE_SIZE / 2) / TILE_SIZE),
        y: Math.floor((py + TILE_SIZE / 2) / TILE_SIZE),
      };
    }

    class Entity {
      constructor(gridX, gridY, size = TILE_SIZE * 0.78) {
        this.size = size;
        this.x = gridX * TILE_SIZE + (TILE_SIZE - size) / 2;
        this.y = gridY * TILE_SIZE + (TILE_SIZE - size) / 2;
      }

      get gridX() {
        return Math.floor((this.x + this.size / 2) / TILE_SIZE);
      }

      get gridY() {
        return Math.floor((this.y + this.size / 2) / TILE_SIZE);
      }

      hitRect(other) {
        return (
          this.x < other.x + other.size &&
          this.x + this.size > other.x &&
          this.y < other.y + other.size &&
          this.y + this.size > other.y
        );
      }
    }

    class Player extends Entity {
      constructor() {
        super(1, 1, TILE_SIZE * 0.8);
        this.alive = true;
        this.targetX = this.x;
        this.targetY = this.y;
        this.moving = false;
        this.moveCooldown = 0;
        this.bombsPlaced = 0;
        this.invincible = 0;
      }

      get speed() {
        return 2.2 + playerStats.speedTier * 0.25;
      }

      update() {
        if (!this.alive) return;

        if (this.invincible > 0) this.invincible -= 1;
        if (this.moveCooldown > 0) this.moveCooldown -= 1;

        if (this.moving) {
          const dx = this.targetX - this.x;
          const dy = this.targetY - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist <= this.speed) {
            this.x = this.targetX;
            this.y = this.targetY;
            this.moving = false;
            this.moveCooldown = Math.max(6, 14 - playerStats.speedTier * 2);
          } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
          }
        }

        if (!this.moving && this.moveCooldown <= 0) {
          let dx = 0;
          let dy = 0;
          if (input.up) dy = -1;
          else if (input.down) dy = 1;
          else if (input.left) dx = -1;
          else if (input.right) dx = 1;
          if (dx || dy) this.tryMove(dx, dy);
        }

        if (input.bomb) {
          this.placeBomb();
          input.bomb = false;
        }

        for (let i = items.length - 1; i >= 0; i -= 1) {
          if (this.hitRect(items[i])) {
            const item = items[i];
            if (item.type === 'bomb' && playerStats.bombCount < 4) playerStats.bombCount += 1;
            if (item.type === 'range' && playerStats.bombRange < 4) playerStats.bombRange += 1;
            if (item.type === 'speed' && playerStats.speedTier < 4) playerStats.speedTier += 1;
            if (item.type === 'heart' && playerStats.lives < 3) playerStats.lives += 1;
            score += 60;
            items.splice(i, 1);
            refreshHud();
          }
        }
      }

      tryMove(dx, dy) {
        const gx = this.gridX + dx;
        const gy = this.gridY + dy;
        if (gx < 0 || gy < 0 || gx >= MAP_COLS || gy >= MAP_ROWS) return;
        if (map[gy][gx] === WALL || map[gy][gx] === BRICK) return;
        if (bombs.some((b) => b.gx === gx && b.gy === gy)) return;

        this.targetX = gx * TILE_SIZE + (TILE_SIZE - this.size) / 2;
        this.targetY = gy * TILE_SIZE + (TILE_SIZE - this.size) / 2;
        this.moving = true;
      }

      placeBomb() {
        if (this.bombsPlaced >= playerStats.bombCount) return;
        const gx = this.gridX;
        const gy = this.gridY;
        if (bombs.some((b) => b.gx === gx && b.gy === gy)) return;
        bombs.push({ gx, gy, owner: this, timer: 120, range: playerStats.bombRange });
        this.bombsPlaced += 1;
      }

      hurt() {
        if (!this.alive || this.invincible > 0) return;
        this.alive = false;
        playerStats.lives -= 1;
        refreshHud();
        if (playerStats.lives <= 0) {
          gameState = GAME_STATE.GAME_OVER;
          openOverlay();
          return;
        }
        setTimeout(() => {
          this.x = TILE_SIZE + (TILE_SIZE - this.size) / 2;
          this.y = TILE_SIZE + (TILE_SIZE - this.size) / 2;
          this.targetX = this.x;
          this.targetY = this.y;
          this.moving = false;
          this.alive = true;
          this.invincible = 170;
        }, 900);
      }

      draw() {
        if (!this.alive) return;
        if (this.invincible > 0 && Math.floor(this.invincible / 8) % 2 === 0) return;

        const cx = this.x + this.size / 2;
        const cy = this.y + this.size / 2;
        const bob = Math.sin(performance.now() / 160) * 0.8;

        ctx.shadowColor = 'rgba(56, 189, 248, 0.5)';
        ctx.shadowBlur = 12;

        const grad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.size);
        grad.addColorStop(0, '#60a5fa');
        grad.addColorStop(1, '#2563eb');
        ctx.fillStyle = grad;
        roundedRectPath(this.x, this.y + bob, this.size, this.size, 10);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        roundedRectPath(this.x + 4, this.y + 4 + bob, this.size - 8, 7, 4);
        ctx.fill();

        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(cx - 5, cy - 2 + bob, 3.2, 0, Math.PI * 2);
        ctx.arc(cx + 5, cy - 2 + bob, 3.2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#0f172a';
        ctx.beginPath();
        ctx.arc(cx - 5, cy - 2 + bob, 1.6, 0, Math.PI * 2);
        ctx.arc(cx + 5, cy - 2 + bob, 1.6, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#e0f2fe';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy + 4 + bob, 5, 0.2, Math.PI - 0.2);
        ctx.stroke();
      }
    }

    class Enemy extends Entity {
      constructor(gridX, gridY, styleIndex = 0) {
        super(gridX, gridY, TILE_SIZE * 0.8);
        this.styleIndex = styleIndex;
        this.dir = [{ x: 0, y: 1 }, { x: 0, y: -1 }, { x: 1, y: 0 }, { x: -1, y: 0 }][Math.floor(Math.random() * 4)];
        this.cooldown = Math.floor(Math.random() * 64) + 28;
        this.alive = true;
      }

      update() {
        if (!this.alive) return;

        this.cooldown -= 1;
        if (this.cooldown <= 0) {
          const dirs = [
            this.dir,
            { x: 0, y: 1 },
            { x: 0, y: -1 },
            { x: 1, y: 0 },
            { x: -1, y: 0 },
          ];
          let moved = false;
          for (const d of dirs.sort(() => Math.random() - 0.5)) {
            if (this.tryMove(d.x, d.y)) {
              this.dir = d;
              moved = true;
              break;
            }
          }
          this.cooldown = moved ? Math.max(20, 34 - level) : 24;
        }

        if (player.alive && this.hitRect(player)) player.hurt();
      }

      tryMove(dx, dy) {
        const gx = this.gridX + dx;
        const gy = this.gridY + dy;
        if (gx < 0 || gy < 0 || gx >= MAP_COLS || gy >= MAP_ROWS) return false;
        if (map[gy][gx] === WALL || map[gy][gx] === BRICK) return false;
        if (bombs.some((b) => b.gx === gx && b.gy === gy)) return false;
        this.x = gx * TILE_SIZE + (TILE_SIZE - this.size) / 2;
        this.y = gy * TILE_SIZE + (TILE_SIZE - this.size) / 2;
        return true;
      }

      draw() {
        if (!this.alive) return;

        const theme = ENEMY_THEMES[this.styleIndex % ENEMY_THEMES.length];
        const cx = this.x + this.size / 2;
        const cy = this.y + this.size / 2;
        const bob = Math.sin((performance.now() + this.styleIndex * 120) / 210) * 0.9;

        ctx.shadowColor = `${theme.primary}66`;
        ctx.shadowBlur = 10;
        const grad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.size);
        grad.addColorStop(0, theme.primary);
        grad.addColorStop(1, theme.secondary);
        ctx.fillStyle = grad;
        roundedRectPath(this.x, this.y + bob, this.size, this.size, 10);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = 'rgba(255,255,255,0.28)';
        roundedRectPath(this.x + 4, this.y + 4 + bob, this.size - 8, 6, 4);
        ctx.fill();

        ctx.fillStyle = theme.eye;
        ctx.fillRect(cx - 8, cy - 4 + bob, 5, 5);
        ctx.fillRect(cx + 3, cy - 4 + bob, 5, 5);

        ctx.fillStyle = '#0f172a';
        ctx.fillRect(cx - 7, cy - 3 + bob, 2, 2);
        ctx.fillRect(cx + 4, cy - 3 + bob, 2, 2);

        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - 6, cy + 7 + bob);
        ctx.quadraticCurveTo(cx, cy + 11 + bob, cx + 6, cy + 7 + bob);
        ctx.stroke();
      }
    }

    function spawnExplosion(gx, gy, range, owner) {
      const cells = [{ x: gx, y: gy }];
      const dirs = [
        { x: 1, y: 0 },
        { x: -1, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: -1 },
      ];

      for (const d of dirs) {
        for (let r = 1; r <= range; r += 1) {
          const x = gx + d.x * r;
          const y = gy + d.y * r;
          if (x < 0 || y < 0 || x >= MAP_COLS || y >= MAP_ROWS) break;
          if (map[y][x] === WALL) break;
          cells.push({ x, y });
          if (map[y][x] === BRICK) {
            map[y][x] = TILE;
            score += 10;
            if (exit && exit.x === x && exit.y === y) exit.revealed = true;
            else if (Math.random() < 0.25) {
              const rItem = ['bomb', 'range', 'speed', 'heart'][Math.floor(Math.random() * 4)];
              items.push({ x: x * TILE_SIZE + TILE_SIZE * 0.15, y: y * TILE_SIZE + TILE_SIZE * 0.15, size: TILE_SIZE * 0.7, type: rItem, bob: 0 });
            }
            break;
          }
        }
      }

      explosions.push({ cells, timer: 24 });
      owner.bombsPlaced = Math.max(0, owner.bombsPlaced - 1);

      for (const c of cells) {
        const rect = { x: c.x * TILE_SIZE, y: c.y * TILE_SIZE, size: TILE_SIZE };

        if (player.alive && player.hitRect(rect)) player.hurt();

        for (const e of enemies) {
          if (e.alive && e.hitRect(rect)) {
            e.alive = false;
            score += 120;
          }
        }

        for (const b of bombs) {
          if (b.gx === c.x && b.gy === c.y) b.timer = Math.min(b.timer, 1);
        }
      }
      refreshHud();
    }

    function buildMap() {
      map = [];
      for (let y = 0; y < MAP_ROWS; y += 1) {
        const row = [];
        for (let x = 0; x < MAP_COLS; x += 1) {
          const border = x === 0 || y === 0 || x === MAP_COLS - 1 || y === MAP_ROWS - 1;
          const pillar = x % 2 === 0 && y % 2 === 0;
          if (border || pillar) row.push(WALL);
          else row.push(Math.random() < 0.69 ? BRICK : TILE);
        }
        map.push(row);
      }

      map[1][1] = TILE;
      map[1][2] = TILE;
      map[2][1] = TILE;

      const brickCells = [];
      for (let y = 1; y < MAP_ROWS - 1; y += 1) {
        for (let x = 1; x < MAP_COLS - 1; x += 1) {
          if (map[y][x] === BRICK) brickCells.push({ x, y });
        }
      }
      const pick = brickCells[Math.floor(Math.random() * brickCells.length)] || { x: MAP_COLS - 2, y: MAP_ROWS - 2 };
      exit = { x: pick.x, y: pick.y, revealed: false };
    }

    function spawnEnemies() {
      enemies = [];
      const count = 2 + level;
      const pool = [];
      for (let y = 1; y < MAP_ROWS - 1; y += 1) {
        for (let x = 1; x < MAP_COLS - 1; x += 1) {
          if (map[y][x] === TILE && (x > 4 || y > 4)) pool.push({ x, y });
        }
      }

      for (let i = 0; i < count && pool.length; i += 1) {
        const index = Math.floor(Math.random() * pool.length);
        const { x, y } = pool.splice(index, 1)[0];
        enemies.push(new Enemy(x, y, i + level));
      }
    }

    function refreshHud() {
      levelEl.textContent = `${level} / 10`;
      scoreEl.textContent = String(score);
      livesEl.textContent = 'â¤ï¸'.repeat(Math.max(playerStats.lives, 0));
      enemyCountEl.textContent = String(enemies.filter((e) => e.alive).length);
    }

    function startLevel() {
      buildMap();
      player = new Player();
      bombs = [];
      explosions = [];
      items = [];
      spawnEnemies();
      refreshHud();
      gameState = GAME_STATE.PLAYING;
      overlay.style.display = 'none';
      canvas.focus();
    }

    function resetGame() {
      level = 1;
      score = 0;
      playerStats.lives = 3;
      playerStats.speedTier = 1;
      playerStats.bombCount = 1;
      playerStats.bombRange = 1;
      startLevel();
    }

    function openOverlay() {
      overlay.style.display = 'flex';
      if (gameState === GAME_STATE.START) {
        dialog.innerHTML = `
          <h2>æ€ªç¸å¡”çˆ†çˆ†å†’éšª</h2>
          <p>é‡æ–°åŒ…è£çš„æ‰‹æ©Ÿç‰ˆç‚¸å½ˆç©æ³•ï¼š10 å€‹é—œå¡ã€æ€ªç¸å¡”æ€ªç¸ç™»å ´ã€‚</p>
          <p>ç›®æ¨™ï¼šç‚¸æ‰éšœç¤™ã€æ“Šæ•—å…¨éƒ¨æ€ªç¸ï¼Œæ‰¾åˆ°å‡ºå£å³å¯éé—œã€‚</p>
          <button class="cta" id="startBtn">é–‹å§‹å†’éšª</button>
        `;
      }

      if (gameState === GAME_STATE.LEVEL_CLEAR) {
        dialog.innerHTML = `
          <h2>ç¬¬ ${level} é—œå®Œæˆï¼</h2>
          <p>æº–å‚™é€²å…¥ä¸‹ä¸€é—œæ€ªç¸æˆ°å ´...</p>
        `;
      }

      if (gameState === GAME_STATE.GAME_OVER) {
        dialog.innerHTML = `
          <h2>æŒ‘æˆ°çµæŸ</h2>
          <p>æœ€çµ‚åˆ†æ•¸ï¼š${score}</p>
          <button class="cta" id="restartBtn">é‡æ–°æŒ‘æˆ°</button>
        `;
      }

      if (gameState === GAME_STATE.GAME_WIN) {
        dialog.innerHTML = `
          <h2>å…¨ 10 é—œé€šé—œï¼</h2>
          <p>æ­å–œå®Œæˆæ€ªç¸å¡”çˆ†çˆ†å†’éšªï¼</p>
          <p>æœ€çµ‚åˆ†æ•¸ï¼š${score}</p>
          <button class="cta" id="restartBtn">å†ç©ä¸€æ¬¡</button>
        `;
      }

      document.getElementById('startBtn')?.addEventListener('click', resetGame);
      document.getElementById('restartBtn')?.addEventListener('click', resetGame);
    }

    function update() {
      if (gameState !== GAME_STATE.PLAYING) return;

      player.update();

      for (const e of enemies) e.update();
      enemies = enemies.filter((e) => e.alive);

      for (let i = bombs.length - 1; i >= 0; i -= 1) {
        bombs[i].timer -= 1;
        if (bombs[i].timer <= 0) {
          const b = bombs.splice(i, 1)[0];
          spawnExplosion(b.gx, b.gy, b.range, b.owner);
        }
      }

      for (let i = explosions.length - 1; i >= 0; i -= 1) {
        explosions[i].timer -= 1;
        if (explosions[i].timer <= 0) explosions.splice(i, 1);
      }

      for (const item of items) item.bob += 0.08;

      refreshHud();

      if (enemies.length === 0 && exit.revealed) {
        const extRect = { x: exit.x * TILE_SIZE, y: exit.y * TILE_SIZE, size: TILE_SIZE };
        if (player.alive && player.hitRect(extRect)) {
          score += 500;
          if (level >= 10) {
            gameState = GAME_STATE.GAME_WIN;
            openOverlay();
          } else {
            level += 1;
            gameState = GAME_STATE.LEVEL_CLEAR;
            openOverlay();
            setTimeout(startLevel, 1000);
          }
        }
      }
    }

    function drawMap() {
      if (!Array.isArray(map) || map.length !== MAP_ROWS) {
        ctx.fillStyle = '#0e1b2f';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return;
      }

      for (let y = 0; y < MAP_ROWS; y += 1) {
        for (let x = 0; x < MAP_COLS; x += 1) {
          const base = (x + y) % 2 === 0 ? '#183355' : '#1d3b63';
          ctx.fillStyle = base;
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

          if (map[y][x] === WALL) {
            ctx.fillStyle = '#3b4e73';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, 4);
          }

          if (map[y][x] === BRICK) {
            ctx.fillStyle = '#b45309';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = '#78350f';
            ctx.strokeRect(x * TILE_SIZE + 1, y * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);
          }
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap();

      if (exit?.revealed) {
        ctx.fillStyle = 'rgba(192, 132, 252, 0.85)';
        ctx.fillRect(exit.x * TILE_SIZE, exit.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('â‡©', exit.x * TILE_SIZE + TILE_SIZE / 2, exit.y * TILE_SIZE + TILE_SIZE / 2 + 1);
      }

      for (const item of items) {
        const y = item.y + Math.sin(item.bob) * 2;
        ctx.fillStyle = '#34d399';
        ctx.fillRect(item.x, y, item.size, item.size);
        ctx.fillStyle = '#fff';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const icon = item.type === 'bomb' ? 'ğŸ’£' : item.type === 'range' ? 'ğŸ”¥' : item.type === 'speed' ? 'âš¡' : 'â¤ï¸';
        ctx.fillText(icon, item.x + item.size / 2, y + item.size / 2 + 1);
      }

      for (const b of bombs) {
        const x = b.gx * TILE_SIZE + TILE_SIZE / 2;
        const y = b.gy * TILE_SIZE + TILE_SIZE / 2;
        const pulse = 14 + Math.sin((120 - b.timer) / 7) * 2;
        ctx.fillStyle = '#111827';
        ctx.beginPath();
        ctx.arc(x, y, pulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fef3c7';
        ctx.beginPath();
        ctx.arc(x - 4, y - 4, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      player?.draw();
      for (const e of enemies) e.draw();

      for (const exp of explosions) {
        const alpha = exp.timer / 24;
        for (const c of exp.cells) {
          const cx = c.x * TILE_SIZE + TILE_SIZE / 2;
          const cy = c.y * TILE_SIZE + TILE_SIZE / 2;
          const r = TILE_SIZE * 0.55;
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
          g.addColorStop(0, `rgba(255,244,174,${alpha})`);
          g.addColorStop(0.6, `rgba(250,204,21,${alpha * 0.9})`);
          g.addColorStop(1, 'rgba(251,146,60,0)');
          ctx.fillStyle = g;
          ctx.fillRect(c.x * TILE_SIZE, c.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') { input.up = true; e.preventDefault(); }
      if (e.key === 'ArrowDown') { input.down = true; e.preventDefault(); }
      if (e.key === 'ArrowLeft') { input.left = true; e.preventDefault(); }
      if (e.key === 'ArrowRight') { input.right = true; e.preventDefault(); }
      if (e.key === ' ') { input.bomb = true; e.preventDefault(); }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowUp') input.up = false;
      if (e.key === 'ArrowDown') input.down = false;
      if (e.key === 'ArrowLeft') input.left = false;
      if (e.key === 'ArrowRight') input.right = false;
    });

    let touchStart = null;
    let lastTapAt = 0;
    let lastTapPos = null;

    canvas.addEventListener('pointerdown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const now = performance.now();

      if (now - lastTapAt < 280 && lastTapPos) {
        const dist = Math.hypot(lastTapPos.x - x, lastTapPos.y - y);
        if (dist < 45) input.bomb = true;
      }
      lastTapAt = now;
      lastTapPos = { x, y };
      touchStart = { x, y };
      canvas.setPointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!touchStart || gameState !== GAME_STATE.PLAYING) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const dx = x - touchStart.x;
      const dy = y - touchStart.y;

      if (Math.hypot(dx, dy) < 24) return;

      input.up = input.down = input.left = input.right = false;
      if (Math.abs(dx) > Math.abs(dy)) {
        input.right = dx > 0;
        input.left = dx < 0;
      } else {
        input.down = dy > 0;
        input.up = dy < 0;
      }

      touchStart = { x, y };
    });

    canvas.addEventListener('pointerup', () => {
      input.up = input.down = input.left = input.right = false;
      touchStart = null;
    });

    canvas.addEventListener('pointercancel', () => {
      input.up = input.down = input.left = input.right = false;
      touchStart = null;
    });

    bombBtn.addEventListener('click', () => {
      input.bomb = true;
      canvas.focus();
    });

    refreshHud();
    openOverlay();
    gameLoop();
  </script>
</body>
</html>